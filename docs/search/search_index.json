{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"index.html","text":"Getting Started with Bash Scripting \u00b6 Bash is a Unix shell, which is a command-line interface for interacting with an operating system. It is widely used for various purposes such as automation, task management, and more. This guide will help you understand the basics of bash scripting and how to get started with writing your own bash scripts. Prerequisites \u00b6 Before you start writing bash scripts, you should have a basic understanding of the following: The command line interface Basic Linux/Unix commands Familiarity with programming concepts (e.g., variables, loops, functions, etc.) Setting up the environment \u00b6 To start writing bash scripts, you will need a text editor and a terminal. Most Linux/Unix systems come with a terminal and the vi or nano text editor installed by default. If you\u2019re using Windows, you can install a Linux environment such as Git Bash or Windows Subsystem for Linux. Writing your first script \u00b6 Bash scripts are simply text files with a .sh extension that contain a series of commands to be executed. To create your first script, follow these steps: Open your terminal and navigate to the directory where you want to save your script. Create a new file using the nano text editor by typing nano myscript.sh. Type the following code into the file #!/bin/bash echo \"Hello, World!\" * Save the file and exit the text editor. * Make the script executable by typing chmod +x myscript.sh. * Run the script by typing ./myscript.sh. Follow Along to Learn more","title":"Getting Started with Bash Scripting"},{"location":"index.html#getting-started-with-bash-scripting","text":"Bash is a Unix shell, which is a command-line interface for interacting with an operating system. It is widely used for various purposes such as automation, task management, and more. This guide will help you understand the basics of bash scripting and how to get started with writing your own bash scripts.","title":"Getting Started with Bash Scripting"},{"location":"index.html#prerequisites","text":"Before you start writing bash scripts, you should have a basic understanding of the following: The command line interface Basic Linux/Unix commands Familiarity with programming concepts (e.g., variables, loops, functions, etc.)","title":"Prerequisites"},{"location":"index.html#setting-up-the-environment","text":"To start writing bash scripts, you will need a text editor and a terminal. Most Linux/Unix systems come with a terminal and the vi or nano text editor installed by default. If you\u2019re using Windows, you can install a Linux environment such as Git Bash or Windows Subsystem for Linux.","title":"Setting up the environment"},{"location":"index.html#writing-your-first-script","text":"Bash scripts are simply text files with a .sh extension that contain a series of commands to be executed. To create your first script, follow these steps: Open your terminal and navigate to the directory where you want to save your script. Create a new file using the nano text editor by typing nano myscript.sh. Type the following code into the file #!/bin/bash echo \"Hello, World!\" * Save the file and exit the text editor. * Make the script executable by typing chmod +x myscript.sh. * Run the script by typing ./myscript.sh. Follow Along to Learn more","title":"Writing your first script"},{"location":"E_bash_arithmetic_operations.html","text":"Arithmetic operations \u00b6 Bash Arithmetic Operators \u00b6 | Arithmetic Operator | Description | | --------------------------------------- | ------------------------------------------------------------------------ | -------------------- | ---------- | | +, - | Addition and subtraction | | *, /, % | Multiplication, division, and remainder (modulo) | | ** | Exponentiation | | <=, >=, <, > | Less than or equal, greater than or equal , less than, and greater than. | | ==, != | Equality (equal to) and inequality (not equal to) | | =, *=, /=, %=, +=, -=, \u00ab=, \u00bb=, &=, ^=, | = | Assignment operators | | id++, id \u2013 | Variable post-increment and post-decrement | | ++id, \u2013id | Variable pre-increment and pre-decrement | | && | Logical AND | | | | | Logical OR | | -, + | Unary minus, plus | | !, ~ | Logical and bitwise negation | | \u00ab, \u00bb | Left and right bitwise shifts | | & | Bitwise AND | | ^ | Bitwise XOR | | | | Bitwise OR | | expression ? expression : expression | conditional ternary operator | Using expr to perform arithmetic operations \u00b6 #!/bin/bash # Basic arithmetic using expr : \" Because expr is a binary rather than a shell builtin, this method may be slow. In a large for-loop, it will fork a new process, which is undesirable. Furthermore, depending on the implementation, the behavior of expr may differ between systems. In contrast to let, you do not need to enclose the expression in quotes. There must also be spaces between the expression's items. To save the output to a variable, like any other command you can use command substitution to capture the output of expr into a variable. \" # expr syntax expr item1 operator item2 # Note that there must be spaces between the items and no quotes. expr 7 + 5 #=> 13 expr \"6 + 3\" #=> 6 + 3 # if you put qoutes the expression will not be evaluated but printed instead. expr 3 +2 #=> 3+2 # The asterisk has special meaning in bash so we must escape it using \\ to remove its special meaning. expr 5 \\* 3 # modulus operator demonstration expr 15 % 2 #=> 1 # using command substitution to save output to a variable result = $( expr 15 - 2 ) echo $result #=> 13 \ud83d\udca1 The square brackets `$[...]`can also do Arithmetic Expansion in Bash, though this notation has been deprecated and should be avoided. Instead, prefer the use of `$((...))` instead. Like let you can also use the `declare`builtin with the `-i` option to do arithmetic operations Using let to perform arithmetic operations \u00b6 #!/bin/bash # Basic arithmetic using let : \" let is a Bash built-in function that allows us to perform simple arithmetic. The arithmetic expression can take several forms, which we'll go over below. However, the first part is always a variable into which the result is saved. \" # The let has the following syntax: let <arithmetic expression> # It is important to note that if we do not use quotes around the expression, it must be written without # spaces. let result = 6 +4 echo $result #=> 10 # This time, we used quotes to space out the expression and make it more readable. let \"result = 4 + 4\" echo $result #=> 8 # incremeting the result same as let result =result+1 or let result+=1 let result++ echo $result #=> 9 # doing some multiplication let \"result = 4 * 5\" echo $result # 20 # We can also use variables in expressions let \"result = $1 + 30\" echo $result # 30 + first command line argument Using d****ouble parentheses for arithmetic operations** \u00b6 #!/bin/bash # Basic arithmetic using double parenthesis : \" The Arithmetic Expansion capability of the shell is the recommended way for evaluating arithmetic expressions with integers in Bash. The built-in shell expansion allows you to perform math calculations by using parentheses ((...)). \" # The Bash arithmetic expansion is written in the format: $(( arithmetic expression )) # you can space out without the need for quotaions to improve readabilty result = $(( 6 + 5 )) echo $result #=> 11 # this works the same result = $(( 3 + 7 )) echo $result #=> 10 # you can include other variables without the need of using $ on them, notice **result** variable below. result2 = $(( result + 3 )) echo $result2 #=> 11 # you can inlcude variables with $ if you prefer. result2 = $(( $result + 4 )) echo $result2 #=> 14 # when incrementing the variable you don't include the $ sign (( result2++ )) echo $result2 #=> 15 # incrementing the value by 3 this is the shorthand for result2 = result2 + 4. (( result2 += 4 )) echo $result2 #=> 19 # Unlike other methods, when we do multiplication we don't need to escape the * sign. This what makes this # method so powerful and versatile. result = $(( 4 * 5 )) echo $result #=> 20","title":"Arithmetic operations"},{"location":"E_bash_arithmetic_operations.html#arithmetic-operations","text":"","title":"Arithmetic operations"},{"location":"E_bash_arithmetic_operations.html#bash-arithmetic-operators","text":"| Arithmetic Operator | Description | | --------------------------------------- | ------------------------------------------------------------------------ | -------------------- | ---------- | | +, - | Addition and subtraction | | *, /, % | Multiplication, division, and remainder (modulo) | | ** | Exponentiation | | <=, >=, <, > | Less than or equal, greater than or equal , less than, and greater than. | | ==, != | Equality (equal to) and inequality (not equal to) | | =, *=, /=, %=, +=, -=, \u00ab=, \u00bb=, &=, ^=, | = | Assignment operators | | id++, id \u2013 | Variable post-increment and post-decrement | | ++id, \u2013id | Variable pre-increment and pre-decrement | | && | Logical AND | | | | | Logical OR | | -, + | Unary minus, plus | | !, ~ | Logical and bitwise negation | | \u00ab, \u00bb | Left and right bitwise shifts | | & | Bitwise AND | | ^ | Bitwise XOR | | | | Bitwise OR | | expression ? expression : expression | conditional ternary operator |","title":"Bash Arithmetic Operators"},{"location":"E_bash_arithmetic_operations.html#using-expr-to-perform-arithmetic-operations","text":"#!/bin/bash # Basic arithmetic using expr : \" Because expr is a binary rather than a shell builtin, this method may be slow. In a large for-loop, it will fork a new process, which is undesirable. Furthermore, depending on the implementation, the behavior of expr may differ between systems. In contrast to let, you do not need to enclose the expression in quotes. There must also be spaces between the expression's items. To save the output to a variable, like any other command you can use command substitution to capture the output of expr into a variable. \" # expr syntax expr item1 operator item2 # Note that there must be spaces between the items and no quotes. expr 7 + 5 #=> 13 expr \"6 + 3\" #=> 6 + 3 # if you put qoutes the expression will not be evaluated but printed instead. expr 3 +2 #=> 3+2 # The asterisk has special meaning in bash so we must escape it using \\ to remove its special meaning. expr 5 \\* 3 # modulus operator demonstration expr 15 % 2 #=> 1 # using command substitution to save output to a variable result = $( expr 15 - 2 ) echo $result #=> 13 \ud83d\udca1 The square brackets `$[...]`can also do Arithmetic Expansion in Bash, though this notation has been deprecated and should be avoided. Instead, prefer the use of `$((...))` instead. Like let you can also use the `declare`builtin with the `-i` option to do arithmetic operations","title":"Using expr to perform arithmetic operations"},{"location":"E_bash_arithmetic_operations.html#using-let-to-perform-arithmetic-operations","text":"#!/bin/bash # Basic arithmetic using let : \" let is a Bash built-in function that allows us to perform simple arithmetic. The arithmetic expression can take several forms, which we'll go over below. However, the first part is always a variable into which the result is saved. \" # The let has the following syntax: let <arithmetic expression> # It is important to note that if we do not use quotes around the expression, it must be written without # spaces. let result = 6 +4 echo $result #=> 10 # This time, we used quotes to space out the expression and make it more readable. let \"result = 4 + 4\" echo $result #=> 8 # incremeting the result same as let result =result+1 or let result+=1 let result++ echo $result #=> 9 # doing some multiplication let \"result = 4 * 5\" echo $result # 20 # We can also use variables in expressions let \"result = $1 + 30\" echo $result # 30 + first command line argument","title":"Using let to perform arithmetic operations"},{"location":"E_bash_arithmetic_operations.html#using-double-parentheses-for-arithmetic-operations","text":"#!/bin/bash # Basic arithmetic using double parenthesis : \" The Arithmetic Expansion capability of the shell is the recommended way for evaluating arithmetic expressions with integers in Bash. The built-in shell expansion allows you to perform math calculations by using parentheses ((...)). \" # The Bash arithmetic expansion is written in the format: $(( arithmetic expression )) # you can space out without the need for quotaions to improve readabilty result = $(( 6 + 5 )) echo $result #=> 11 # this works the same result = $(( 3 + 7 )) echo $result #=> 10 # you can include other variables without the need of using $ on them, notice **result** variable below. result2 = $(( result + 3 )) echo $result2 #=> 11 # you can inlcude variables with $ if you prefer. result2 = $(( $result + 4 )) echo $result2 #=> 14 # when incrementing the variable you don't include the $ sign (( result2++ )) echo $result2 #=> 15 # incrementing the value by 3 this is the shorthand for result2 = result2 + 4. (( result2 += 4 )) echo $result2 #=> 19 # Unlike other methods, when we do multiplication we don't need to escape the * sign. This what makes this # method so powerful and versatile. result = $(( 4 * 5 )) echo $result #=> 20","title":"Using d****ouble parentheses for arithmetic operations**"},{"location":"E_bash_arrays.html","text":"Bash Arrays \u00b6 Bash Arrays \u00b6 Array Declaration syntax \u00b6 Syntax Description ARRAY=() Declares an indexed array ARRAY and initializes it to be empty. This can also be used to empty an existing array. ARRAY[0]= Generally sets the first element of an indexed array. If no array ARRAY existed before, it is created. declare -a ARRAY Declares an indexed array ARRAY. An existing array is not initialized. declare -A ARRAY Declares an associative array ARRAY. This is the one and only way to create associative arrays in bash. Indexes and Metadata \u00b6 ${ARRAY[0]} get the first element (refer to Getting values table) ${ARRAY[-1]} get the last element (refer to Getting values table) ${ARRAY[*]} get all the elements (refer to Getting values table) ${ARRAY[@]} get all the elements as well(refer to Getting values table) | ${#ARRAY[@]} ${#ARRAY[ ]} | Expands to the number of elements in ARRAY | | ${#ARRAY} | Expand to the length of the first element. | | ${#ARRAY[N]} | Expands to the length of an individual array member at index N. If the Nth element is a string it gets the (stringlength) | | ${#ARRAY[STRING]} | Expands to the length of an individual associative array member at index STRING (stringlength) | | ${#ARRAY[@]:N:M} ${#ARRAY[ ]:N:M} | Expands to the number of elements to M starting from N . The M can be omitted and the it will expand from N up to the last element. | | ${!ARRAY[@]} ${!ARRAY[*]} | Expands to the indexes in ARRAY since BASH 3.0 | Destroying Arrays \u00b6 The unset builtin command is used to destroy (unset) arrays or individual elements of arrays. Syntax Description | unset -v ARRAY unset -v ARRAY[@] unset -v ARRAY[ ] | Destroys a complete array | | unset -v \u2018ARRAY[N]\u2019 | Destroys the array element at index N . https://wiki.bash-hackers.org/syntax/arrays#destruction | | ARRAY=( ${ARRAY[@]/STR /} ) ARRAY=( ${ARRAY[*]/STR*/} ) | Remove values by regular expressions (STR short for string) | | unset -v ARRAY[STRING] | Destroys the array element of the associative array at index STRING | Storing Values \u00b6 Syntax Description ARRAY[N]=VALUE Sets the element N of the indexed array ARRAY to VALUE. N can be any valid https://wiki.bash-hackers.org/syntax/arith_expr. ARRAY[STRING]=VALUE Sets the element indexed by STRING of the associative array ARRAY. ARRAY=VALUE As above. If no index is given, as a default the zeroth element is set to VALUE. Careful, this is even true of associative arrays - there is no error if no key is specified, and the value is assigned to string index \u201c0\u201d. ARRAY=(E1 E2 \u2026) Compound array assignment - sets the whole array ARRAY to the given list of elements indexed sequentially starting at zero. The array is unset before assignment unless the += operator is used. When the list is empty (ARRAY=()), the array will be set to an empty array. This method obviously does not use explicit indexes. An associative array can not be set like that! Clearing an associative array using ARRAY=() works. ARRAY=([X]=E1 [Y]=E2 \u2026) Compound assignment for indexed arrays with index-value pairs declared individually (here for example X and Y). X and Y are arithmetic expressions. This syntax can be combined with the above - elements declared without an explicitly specified index are assigned sequentially starting at either the last element with an explicit index, or zero. ARRAY=([S1]=E1 [S2]=E2 \u2026) Individual mass-setting for associative arrays. The named indexes (here: S1 and S2) are strings. | ARRAY+=(E1 E2 \u2026) ARRAY=(\u201c {ARRAY[@]}\" E1 ...) | Append to ARRAY. | | ARRAY=(\" {ARRAY[@]}\" E1 ...) | Append to ARRAY. | | ARRAY=(\" \u201d) | Copy ANOTHER_ARRAY to ARRAY, copying each element. You can omit the quotations: ARRAY=( {ANOTHER_ARRAY[@]}) | | ARRAY=(\" {ANOTHER_ARRAY[@]}) | | ARRAY=(\" ARRAY[@]}\u201d \u201c {ANOTHER_ARRAY[@]}\") | Concatenating Arrays. Quotations can be omitted : ARRAY=( {ANOTHER_ARRAY[@]}\") | Concatenating Arrays. Quotations can be omitted : ARRAY=( ARRAY[@]} {ANOTHER_ARRAY[@]}) and you can also replace @ with * | | ARRAY=( {ANOTHER_ARRAY[@]}) and you can also replace @ with * | | ARRAY=( (cat file)) | storing array values from reading a file. | | ARRAY=({N..M}) | Getting array values from brace expansion N and M can be strings or numeric values (see Array Discussion) | * *Getting values** \u00b6 Syntax Description ${ARRAY[N]} Expands to the value of the index N in the indexed array ARRAY. If N is a negative number, it\u2019s treated as the offset from the maximum assigned index (can\u2019t be used for assignment) - 1 ${ARRAY[S]} Expands to the value of the index S in the associative array ARRAY. | \u201c${ARRAY[@]}\u201d {ARRAY[@]} \" {ARRAY[@]} \" {ARRAY[ ]}\u201d {ARRAY[*]} | Similar to https://wiki.bash-hackers.org/scripting/posparams#mass_usage, this expands to all elements. If unquoted, both subscripts * and @ expand to the same result, if quoted, @ expands to all elements individually quoted, * expands to all elements quoted as a whole (tested all these scenarios, but they don\u2019t seem to produce intended results on my version of bash). | | \" {ARRAY[*]} | Similar to https://wiki.bash-hackers.org/scripting/posparams#mass_usage, this expands to all elements. If unquoted, both subscripts * and @ expand to the same result, if quoted, @ expands to all elements individually quoted, * expands to all elements quoted as a whole (tested all these scenarios, but they don\u2019t seem to produce intended results on my version of bash). | | \" \u201d {ARRAY[@]:N:M} \" {ARRAY[@]:N:M} \" {ARRAY[ ]:N:M}\u201d ${ARRAY[*]:N:M} | Similar to what this syntax does for the characters of a single string when doing https://wiki.bash-hackers.org/syntax/pe#substring_expansion, this expands to M elements starting with element N. This way you can mass-expand individual indexes. The rules for quoting and the subscripts * and @ are the same as above for the other mass-expansions. | \ud83d\udd17 For clarification: When you use the subscripts `@` or `*` for mass-expanding, then the behaviour is exactly what it is for `$@` and `$*` when [mass-expanding the positional parameters](https://wiki.bash-hackers.org/scripting/posparams#mass_usage). You should read this article to understand what's going on. \ud83d\udca1 It is best to [explicitly specify -v](https://wiki.bash-hackers.org/commands/builtin/unset#portability_considerations) when unsetting variables with unset. \ud83d\udca1 [Learn more about bash Arrays here](https://wiki.bash-hackers.org/syntax/arrays) Array Discussion \u00b6 Compound indexed array assignment \u00b6 # : ' Compound array assignment - sets the whole array NAMES to the given list of elements. ' # NAMES => Creg Jan Anna NAMES =( 'Creg' 'Jan' 'Anna' ) # using the declare construct declare -a Numbers =( 1 2 3 ) Indexed array assignment using brace expansion \u00b6 ARRAY1 =( foo { 1 ..2 }) # => foo1 foo2 ARRAY2 =({ A..D }) # => A B C D ARRAY3 =({ 1 ..5 }) # => 1 2 3 4 5 ARRAY4 =({ A..B }{ 1 ..2 }) #=> A1 A2 B1 B2 Index array assignment \u00b6 : ' Sets the element N of the indexed array NAMES to VALUE. N can be any valid arithmetic expression. ' NAMES [ 0 ]= 'Creg' NAMES [ 1 ]= 'Jan' NAMES [ 2 ]= 'Anna' # NAMES => Creg Jan Anna Appending values to arrays \u00b6 NAMES =( 'Creg' 'Jan' 'Anna' ) NAMES +=( 'Jay' 'Jimmy' 'Tom' ) # NAMES => Creg Jan Anna Jay Jimmy Tom # This is also the same as NAMES =( ${ NAMES [@] } 'Jay' 'Jimmy' 'Tom' ) # NAMES => Creg Jan Anna Jay Jimmy Tom Compound associative array assignment \u00b6 : ' Individual mass-setting for **associative arrays**. The named indexes (here: name, age....) are strings. ' declare -A person # this line is required # quotes can me omitted for the keys, see the **age** key below person =([ \"name\" ]= \"Jay\" [ age ]= 22 [ \"eye_color\" ]= \"blue\" ) # person => Jay 22 blue Merging/Concatenating Arrays \u00b6 ARRAY1 =( foo { 1 ..2 }) # => foo1 foo2 ARRAY2 =({ A..D }) # => A B C D ARRAY3 =({ 1 ..5 }) # => 1 2 3 4 5 # Merge Arrays => foo1 foo2 A B C D 1 2 3 4 5 ARRAY4 =( ${ ARRAY1 [@] } ${ ARRAY2 [@] } ${ ARRAY3 [@] } ) The **@** can also be replace with a ***** Key associative array assignment \u00b6 declare -A person person [ name ]= \"Jay\" person [ age ]= 22 person [ eye_color ]= \"blue\" # person => Jay 22 blue Iterating an indexed array \u00b6 names =( 'Jay' 'Joe' 'Jimmy' ) for name in \" ${ names [@] } \" ; do echo $name done # using index for i in \" ${ !names[@] } \" ; do printf \"%s\\t%s\\n\" \" $i \" \" ${ names [ $i ] } \" done Working with associative arrays \u00b6 declare -A person person =([ \"name\" ]= \"Jay\" [ age ]= 22 [ \"eye_color\" ]= \"blue\" ) echo ${ person [name] } # Get person's name echo ${ sounds [@] } # Get all person's values echo ${ sounds [*] } # Get all person's values echo ${ !person[@] } # All person's keys (age, name...) echo ${# person [@] } # Number of elements unset -v person [ age ] # Delete person's age # All of the above operations workes with index arrays, just that you only # replace the keys with indexes Iterating an associative array \u00b6 declare -A person person =([ \"name\" ]= \"Jay\" [ age ]= 22 [ \"eye_color\" ]= \"blue\" ) for value in \" ${ person [@] } \" ; do echo $value done # Using keys for key in \" ${ !person[@] } \" ; do echo \" $key ${ person [key] } \" done Array arguments \u00b6 function extract () { # creating a local array from function argument 1 ($1) local -n local_names = $1 # creating a local index from function argument 2 ($2) local index = $2 echo \" ${ local_names [ $index ] } \" } # defining global array names names =( 'Jay' 'Joe' 'Jimmy' ) extract names 2 # => Jimmy","title":"Bash Arrays"},{"location":"E_bash_arrays.html#bash-arrays","text":"","title":"Bash Arrays"},{"location":"E_bash_arrays.html#bash-arrays_1","text":"","title":"Bash Arrays"},{"location":"E_bash_arrays.html#array-declaration-syntax","text":"Syntax Description ARRAY=() Declares an indexed array ARRAY and initializes it to be empty. This can also be used to empty an existing array. ARRAY[0]= Generally sets the first element of an indexed array. If no array ARRAY existed before, it is created. declare -a ARRAY Declares an indexed array ARRAY. An existing array is not initialized. declare -A ARRAY Declares an associative array ARRAY. This is the one and only way to create associative arrays in bash.","title":"Array Declaration syntax"},{"location":"E_bash_arrays.html#indexes-and-metadata","text":"${ARRAY[0]} get the first element (refer to Getting values table) ${ARRAY[-1]} get the last element (refer to Getting values table) ${ARRAY[*]} get all the elements (refer to Getting values table) ${ARRAY[@]} get all the elements as well(refer to Getting values table) | ${#ARRAY[@]} ${#ARRAY[ ]} | Expands to the number of elements in ARRAY | | ${#ARRAY} | Expand to the length of the first element. | | ${#ARRAY[N]} | Expands to the length of an individual array member at index N. If the Nth element is a string it gets the (stringlength) | | ${#ARRAY[STRING]} | Expands to the length of an individual associative array member at index STRING (stringlength) | | ${#ARRAY[@]:N:M} ${#ARRAY[ ]:N:M} | Expands to the number of elements to M starting from N . The M can be omitted and the it will expand from N up to the last element. | | ${!ARRAY[@]} ${!ARRAY[*]} | Expands to the indexes in ARRAY since BASH 3.0 |","title":"Indexes and Metadata"},{"location":"E_bash_arrays.html#destroying-arrays","text":"The unset builtin command is used to destroy (unset) arrays or individual elements of arrays. Syntax Description | unset -v ARRAY unset -v ARRAY[@] unset -v ARRAY[ ] | Destroys a complete array | | unset -v \u2018ARRAY[N]\u2019 | Destroys the array element at index N . https://wiki.bash-hackers.org/syntax/arrays#destruction | | ARRAY=( ${ARRAY[@]/STR /} ) ARRAY=( ${ARRAY[*]/STR*/} ) | Remove values by regular expressions (STR short for string) | | unset -v ARRAY[STRING] | Destroys the array element of the associative array at index STRING |","title":"Destroying Arrays"},{"location":"E_bash_arrays.html#storing-values","text":"Syntax Description ARRAY[N]=VALUE Sets the element N of the indexed array ARRAY to VALUE. N can be any valid https://wiki.bash-hackers.org/syntax/arith_expr. ARRAY[STRING]=VALUE Sets the element indexed by STRING of the associative array ARRAY. ARRAY=VALUE As above. If no index is given, as a default the zeroth element is set to VALUE. Careful, this is even true of associative arrays - there is no error if no key is specified, and the value is assigned to string index \u201c0\u201d. ARRAY=(E1 E2 \u2026) Compound array assignment - sets the whole array ARRAY to the given list of elements indexed sequentially starting at zero. The array is unset before assignment unless the += operator is used. When the list is empty (ARRAY=()), the array will be set to an empty array. This method obviously does not use explicit indexes. An associative array can not be set like that! Clearing an associative array using ARRAY=() works. ARRAY=([X]=E1 [Y]=E2 \u2026) Compound assignment for indexed arrays with index-value pairs declared individually (here for example X and Y). X and Y are arithmetic expressions. This syntax can be combined with the above - elements declared without an explicitly specified index are assigned sequentially starting at either the last element with an explicit index, or zero. ARRAY=([S1]=E1 [S2]=E2 \u2026) Individual mass-setting for associative arrays. The named indexes (here: S1 and S2) are strings. | ARRAY+=(E1 E2 \u2026) ARRAY=(\u201c {ARRAY[@]}\" E1 ...) | Append to ARRAY. | | ARRAY=(\" {ARRAY[@]}\" E1 ...) | Append to ARRAY. | | ARRAY=(\" \u201d) | Copy ANOTHER_ARRAY to ARRAY, copying each element. You can omit the quotations: ARRAY=( {ANOTHER_ARRAY[@]}) | | ARRAY=(\" {ANOTHER_ARRAY[@]}) | | ARRAY=(\" ARRAY[@]}\u201d \u201c {ANOTHER_ARRAY[@]}\") | Concatenating Arrays. Quotations can be omitted : ARRAY=( {ANOTHER_ARRAY[@]}\") | Concatenating Arrays. Quotations can be omitted : ARRAY=( ARRAY[@]} {ANOTHER_ARRAY[@]}) and you can also replace @ with * | | ARRAY=( {ANOTHER_ARRAY[@]}) and you can also replace @ with * | | ARRAY=( (cat file)) | storing array values from reading a file. | | ARRAY=({N..M}) | Getting array values from brace expansion N and M can be strings or numeric values (see Array Discussion) |","title":"Storing Values"},{"location":"E_bash_arrays.html#getting-values","text":"Syntax Description ${ARRAY[N]} Expands to the value of the index N in the indexed array ARRAY. If N is a negative number, it\u2019s treated as the offset from the maximum assigned index (can\u2019t be used for assignment) - 1 ${ARRAY[S]} Expands to the value of the index S in the associative array ARRAY. | \u201c${ARRAY[@]}\u201d {ARRAY[@]} \" {ARRAY[@]} \" {ARRAY[ ]}\u201d {ARRAY[*]} | Similar to https://wiki.bash-hackers.org/scripting/posparams#mass_usage, this expands to all elements. If unquoted, both subscripts * and @ expand to the same result, if quoted, @ expands to all elements individually quoted, * expands to all elements quoted as a whole (tested all these scenarios, but they don\u2019t seem to produce intended results on my version of bash). | | \" {ARRAY[*]} | Similar to https://wiki.bash-hackers.org/scripting/posparams#mass_usage, this expands to all elements. If unquoted, both subscripts * and @ expand to the same result, if quoted, @ expands to all elements individually quoted, * expands to all elements quoted as a whole (tested all these scenarios, but they don\u2019t seem to produce intended results on my version of bash). | | \" \u201d {ARRAY[@]:N:M} \" {ARRAY[@]:N:M} \" {ARRAY[ ]:N:M}\u201d ${ARRAY[*]:N:M} | Similar to what this syntax does for the characters of a single string when doing https://wiki.bash-hackers.org/syntax/pe#substring_expansion, this expands to M elements starting with element N. This way you can mass-expand individual indexes. The rules for quoting and the subscripts * and @ are the same as above for the other mass-expansions. | \ud83d\udd17 For clarification: When you use the subscripts `@` or `*` for mass-expanding, then the behaviour is exactly what it is for `$@` and `$*` when [mass-expanding the positional parameters](https://wiki.bash-hackers.org/scripting/posparams#mass_usage). You should read this article to understand what's going on. \ud83d\udca1 It is best to [explicitly specify -v](https://wiki.bash-hackers.org/commands/builtin/unset#portability_considerations) when unsetting variables with unset. \ud83d\udca1 [Learn more about bash Arrays here](https://wiki.bash-hackers.org/syntax/arrays)","title":"**Getting values**"},{"location":"E_bash_arrays.html#array-discussion","text":"","title":"Array Discussion"},{"location":"E_bash_arrays.html#compound-indexed-array-assignment","text":"# : ' Compound array assignment - sets the whole array NAMES to the given list of elements. ' # NAMES => Creg Jan Anna NAMES =( 'Creg' 'Jan' 'Anna' ) # using the declare construct declare -a Numbers =( 1 2 3 )","title":"Compound indexed array assignment"},{"location":"E_bash_arrays.html#indexed-array-assignment-using-brace-expansion","text":"ARRAY1 =( foo { 1 ..2 }) # => foo1 foo2 ARRAY2 =({ A..D }) # => A B C D ARRAY3 =({ 1 ..5 }) # => 1 2 3 4 5 ARRAY4 =({ A..B }{ 1 ..2 }) #=> A1 A2 B1 B2","title":"Indexed array assignment using brace expansion"},{"location":"E_bash_arrays.html#index-array-assignment","text":": ' Sets the element N of the indexed array NAMES to VALUE. N can be any valid arithmetic expression. ' NAMES [ 0 ]= 'Creg' NAMES [ 1 ]= 'Jan' NAMES [ 2 ]= 'Anna' # NAMES => Creg Jan Anna","title":"Index array assignment"},{"location":"E_bash_arrays.html#appending-values-to-arrays","text":"NAMES =( 'Creg' 'Jan' 'Anna' ) NAMES +=( 'Jay' 'Jimmy' 'Tom' ) # NAMES => Creg Jan Anna Jay Jimmy Tom # This is also the same as NAMES =( ${ NAMES [@] } 'Jay' 'Jimmy' 'Tom' ) # NAMES => Creg Jan Anna Jay Jimmy Tom","title":"Appending values to arrays"},{"location":"E_bash_arrays.html#compound-associative-array-assignment","text":": ' Individual mass-setting for **associative arrays**. The named indexes (here: name, age....) are strings. ' declare -A person # this line is required # quotes can me omitted for the keys, see the **age** key below person =([ \"name\" ]= \"Jay\" [ age ]= 22 [ \"eye_color\" ]= \"blue\" ) # person => Jay 22 blue","title":"Compound associative array assignment"},{"location":"E_bash_arrays.html#mergingconcatenating-arrays","text":"ARRAY1 =( foo { 1 ..2 }) # => foo1 foo2 ARRAY2 =({ A..D }) # => A B C D ARRAY3 =({ 1 ..5 }) # => 1 2 3 4 5 # Merge Arrays => foo1 foo2 A B C D 1 2 3 4 5 ARRAY4 =( ${ ARRAY1 [@] } ${ ARRAY2 [@] } ${ ARRAY3 [@] } ) The **@** can also be replace with a *****","title":"Merging/Concatenating Arrays"},{"location":"E_bash_arrays.html#key-associative-array-assignment","text":"declare -A person person [ name ]= \"Jay\" person [ age ]= 22 person [ eye_color ]= \"blue\" # person => Jay 22 blue","title":"Key associative array assignment"},{"location":"E_bash_arrays.html#iterating-an-indexed-array","text":"names =( 'Jay' 'Joe' 'Jimmy' ) for name in \" ${ names [@] } \" ; do echo $name done # using index for i in \" ${ !names[@] } \" ; do printf \"%s\\t%s\\n\" \" $i \" \" ${ names [ $i ] } \" done","title":"Iterating an indexed array"},{"location":"E_bash_arrays.html#working-with-associative-arrays","text":"declare -A person person =([ \"name\" ]= \"Jay\" [ age ]= 22 [ \"eye_color\" ]= \"blue\" ) echo ${ person [name] } # Get person's name echo ${ sounds [@] } # Get all person's values echo ${ sounds [*] } # Get all person's values echo ${ !person[@] } # All person's keys (age, name...) echo ${# person [@] } # Number of elements unset -v person [ age ] # Delete person's age # All of the above operations workes with index arrays, just that you only # replace the keys with indexes","title":"Working with associative arrays"},{"location":"E_bash_arrays.html#iterating-an-associative-array","text":"declare -A person person =([ \"name\" ]= \"Jay\" [ age ]= 22 [ \"eye_color\" ]= \"blue\" ) for value in \" ${ person [@] } \" ; do echo $value done # Using keys for key in \" ${ !person[@] } \" ; do echo \" $key ${ person [key] } \" done","title":"Iterating an associative array"},{"location":"E_bash_arrays.html#array-arguments","text":"function extract () { # creating a local array from function argument 1 ($1) local -n local_names = $1 # creating a local index from function argument 2 ($2) local index = $2 echo \" ${ local_names [ $index ] } \" } # defining global array names names =( 'Jay' 'Joe' 'Jimmy' ) extract names 2 # => Jimmy","title":"Array arguments"},{"location":"E_bash_command_line_chaining_operators.html","text":"Command line chaining operators \u00b6 Below are some commonly used chaining operators which you can use with different commands: | Chaining Operator | Description | | ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- | \u2014 | ----------------------------------------------------------------------------------------------------------------------------------------- | | & (Ampersand) | This send a command, script, or process to the background. In short, it makes a command run in the background. | | && (Logical AND) | The && operator will only execute the second command if the first command SUCCEEDS! , in other words if the first command exists with a zero status. | | | | (Logical OR) | It\u2019s much more like an else statement in programming. The | | will only execute the second command if the first command fails. In other words, if the first command exits with a none zero status code. | | ; (Semi-colon) | The command following this operator will execute even if the command preceding this operator is not successfully executed. | | ! (NOT) | The NOT is much like the except statement. It will run all the commands except a given condition. It negates an expression within a command. | | &&- | | (AND-OR) | It\u2019s a combination of the AND OR operator. It\u2019s much like the if-else statement in programming. | | | (Pipe) | The output of the command preceding this operator will act as an input of the command succeeding this operator. In other words the output of another command will be given to the input of the other command. | | >,>>, < (Input-OutputRedirection) | Redirects the output of a command or a group of commands to a file or stream. | | \\ (Concatenation) | Used to concatenate large commands over several lines in the shell. | | () (Precedence) | Allows the commands to execute in precedence order. | | {} (Combination) | The execution of the command succeeding this operator will depend on the execution of the first command. | \ud83d\udca1 [Read more about command line chaining here:](https://linuxopsys.com/topics/bash-chain-operators-in-linux)","title":"Command line chaining operators"},{"location":"E_bash_command_line_chaining_operators.html#command-line-chaining-operators","text":"Below are some commonly used chaining operators which you can use with different commands: | Chaining Operator | Description | | ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- | \u2014 | ----------------------------------------------------------------------------------------------------------------------------------------- | | & (Ampersand) | This send a command, script, or process to the background. In short, it makes a command run in the background. | | && (Logical AND) | The && operator will only execute the second command if the first command SUCCEEDS! , in other words if the first command exists with a zero status. | | | | (Logical OR) | It\u2019s much more like an else statement in programming. The | | will only execute the second command if the first command fails. In other words, if the first command exits with a none zero status code. | | ; (Semi-colon) | The command following this operator will execute even if the command preceding this operator is not successfully executed. | | ! (NOT) | The NOT is much like the except statement. It will run all the commands except a given condition. It negates an expression within a command. | | &&- | | (AND-OR) | It\u2019s a combination of the AND OR operator. It\u2019s much like the if-else statement in programming. | | | (Pipe) | The output of the command preceding this operator will act as an input of the command succeeding this operator. In other words the output of another command will be given to the input of the other command. | | >,>>, < (Input-OutputRedirection) | Redirects the output of a command or a group of commands to a file or stream. | | \\ (Concatenation) | Used to concatenate large commands over several lines in the shell. | | () (Precedence) | Allows the commands to execute in precedence order. | | {} (Combination) | The execution of the command succeeding this operator will depend on the execution of the first command. | \ud83d\udca1 [Read more about command line chaining here:](https://linuxopsys.com/topics/bash-chain-operators-in-linux)","title":"Command line chaining operators"},{"location":"E_bash_conditions_and_flow_control.html","text":"Bash conditions and flow control \u00b6 ToDO \u00b6 - switch statement in conditions and flow control Numeric conditions \u00b6 Condition Description [[INTERGER1 -eq INTEGER2]] INTEGER1 is equal to INTEGER2 [[INTEGER1 -ne INTEGER2]] INTEGER1 is not equal to INTEGER2 [[INTEGER1 -lt INTEGER]] INTEGER1 is less than INTEGER2 [[INTEGER1 -le INTEGER2]] INTEGER1 is less than or equal to INTEGER2 [[INTEGER1 -gt INTEGER2]] INTEGER1 is greater than INTEGER2 [[INTERGER1 -ge INTEGER2]] INTEGER1 is greater than or equal to INTEGER2 (( INTEGER1 < INTEGER2 )) INTEGER1 is less than INTEGER2 (( INTEGER1 <= INTEGER2 )) INTEGER1 is less than INTEGER2 (( INTEGER1 > INTEGER2 )) INTEGER1 is greater than INTEGER2 (( INTEGER1 >= INTEGER2 )) INTEGER1 is greater than or equal to INTEGER2 (( INTEGER1 == INTEGER2 )) INTEGER1 is equal to INTEGER2 (( INTEGER1 != INTEGER2 )) INTEGER1 is not equal to INTEGER2 String conditions \u00b6 Condition Description [[-z STR]] Empty string [[-n STR]] Not empty string [[STR == STR]] Equal [[STR = STR]] Equal (Same above) [[STR < STR]] Less than (ASCII) [[STR > STR]] Greater than (ASCII) [[STR != STR]] Not Equal [[STR =~ REGEXP]] Regexp More conditions \u00b6 Condition Description [[-o noclobber]] If OPTION is enabled. EXPR expression is true ! EXPR negate expression File conditions \u00b6 Condition Expression [[-b FILE]] FILE exists and is block special [[-c FILE]] FILE exists and is character special [[-d FILE]] FILE exists and is a directory [[-e FILE]] FILE exists [[-f FILE]] FILE exists and is a regular file [[-g FILE]] FILE exists and is set-group-ID [[-G FILE]] FILE exists and is owned by the effective group ID [[-h FILE]] FILE exists and is a symbolic link (same as -L) [[-k FILE]] FILE exists and has its sticky bit set [[-L FILE]] FILE exists and is a symbolic link (same as -h) [[-N FILE]] FILE exists and has been modified since it was last read [[-O FILE]] FILE exists and is owned by the effective user ID [[-p FILE]] FILE exists and is a named pipe [[-r FILE]] FILE exists and the user has read access [[-s FILE]] FILE exists and has a size greater than zero [[-S FILE]] FILE exists and is a socket [[-t FD]] file descriptor FD is opened on a terminal [[-u FILE]] FILE exists and its set-user-ID bit is set [[-w FILE]] FILE exists and the user has write access [[-x FILE]] FILE exists and the user has execute (or search) access [[FILE1 -nt FILE2]] FILE1 is newer (modification date) than FILE2 [[FILE1 -ot FILE2]] FILE1 is older than FILE2 [[FILE1 -ef FILE2]] FILE1 and FILE2 have the same device and inode numbers or both files are the same Compound conditions \u00b6 | Condition | Description | | -------------------------------- | ----------------------------------------------------- | -------------- | ----------------------------------------------------- | | [[condition1]] && [[condition2]] | Evaluate to True if both conditions are TRUE | | [[condition1]] | | [[condition2]] | Evaluate to True if either one of the conditions TRUE | | [ condition1 -a condition2 ] | Evaluate to True if both conditions are TRUE | | [ condition1 -o condition2 ] | Evaluate to True if either one of the conditions TRUE | \ud83d\udca1 Note: It is worth mentioning that you can replace all the double square brackets with single square brackets for example : `[[ NUM -eq NUM ]]` can also be written as `[ NUM -eq NUM ]` . This works with all the all conditions except for compound conditions which uses `-a` (AND) and `-o` (OR) as logical operators. Advanced if-then Features \u00b6 Single parentheses (.......) allow you to use subshells in your if statement comparisons. The double parentheses (( epression )) command allows you to incorporate advanced mathematical formulas in your comparisons. check out performing arithmetic operations. The double bracket [[.......]] command provides advanced features for string comparisons.","title":"Bash conditions and flow control"},{"location":"E_bash_conditions_and_flow_control.html#bash-conditions-and-flow-control","text":"","title":"Bash conditions and flow control"},{"location":"E_bash_conditions_and_flow_control.html#todo","text":"- switch statement in conditions and flow control","title":"ToDO"},{"location":"E_bash_conditions_and_flow_control.html#numeric-conditions","text":"Condition Description [[INTERGER1 -eq INTEGER2]] INTEGER1 is equal to INTEGER2 [[INTEGER1 -ne INTEGER2]] INTEGER1 is not equal to INTEGER2 [[INTEGER1 -lt INTEGER]] INTEGER1 is less than INTEGER2 [[INTEGER1 -le INTEGER2]] INTEGER1 is less than or equal to INTEGER2 [[INTEGER1 -gt INTEGER2]] INTEGER1 is greater than INTEGER2 [[INTERGER1 -ge INTEGER2]] INTEGER1 is greater than or equal to INTEGER2 (( INTEGER1 < INTEGER2 )) INTEGER1 is less than INTEGER2 (( INTEGER1 <= INTEGER2 )) INTEGER1 is less than INTEGER2 (( INTEGER1 > INTEGER2 )) INTEGER1 is greater than INTEGER2 (( INTEGER1 >= INTEGER2 )) INTEGER1 is greater than or equal to INTEGER2 (( INTEGER1 == INTEGER2 )) INTEGER1 is equal to INTEGER2 (( INTEGER1 != INTEGER2 )) INTEGER1 is not equal to INTEGER2","title":"Numeric conditions"},{"location":"E_bash_conditions_and_flow_control.html#string-conditions","text":"Condition Description [[-z STR]] Empty string [[-n STR]] Not empty string [[STR == STR]] Equal [[STR = STR]] Equal (Same above) [[STR < STR]] Less than (ASCII) [[STR > STR]] Greater than (ASCII) [[STR != STR]] Not Equal [[STR =~ REGEXP]] Regexp","title":"String conditions"},{"location":"E_bash_conditions_and_flow_control.html#more-conditions","text":"Condition Description [[-o noclobber]] If OPTION is enabled. EXPR expression is true ! EXPR negate expression","title":"More conditions"},{"location":"E_bash_conditions_and_flow_control.html#file-conditions","text":"Condition Expression [[-b FILE]] FILE exists and is block special [[-c FILE]] FILE exists and is character special [[-d FILE]] FILE exists and is a directory [[-e FILE]] FILE exists [[-f FILE]] FILE exists and is a regular file [[-g FILE]] FILE exists and is set-group-ID [[-G FILE]] FILE exists and is owned by the effective group ID [[-h FILE]] FILE exists and is a symbolic link (same as -L) [[-k FILE]] FILE exists and has its sticky bit set [[-L FILE]] FILE exists and is a symbolic link (same as -h) [[-N FILE]] FILE exists and has been modified since it was last read [[-O FILE]] FILE exists and is owned by the effective user ID [[-p FILE]] FILE exists and is a named pipe [[-r FILE]] FILE exists and the user has read access [[-s FILE]] FILE exists and has a size greater than zero [[-S FILE]] FILE exists and is a socket [[-t FD]] file descriptor FD is opened on a terminal [[-u FILE]] FILE exists and its set-user-ID bit is set [[-w FILE]] FILE exists and the user has write access [[-x FILE]] FILE exists and the user has execute (or search) access [[FILE1 -nt FILE2]] FILE1 is newer (modification date) than FILE2 [[FILE1 -ot FILE2]] FILE1 is older than FILE2 [[FILE1 -ef FILE2]] FILE1 and FILE2 have the same device and inode numbers or both files are the same","title":"File conditions"},{"location":"E_bash_conditions_and_flow_control.html#compound-conditions","text":"| Condition | Description | | -------------------------------- | ----------------------------------------------------- | -------------- | ----------------------------------------------------- | | [[condition1]] && [[condition2]] | Evaluate to True if both conditions are TRUE | | [[condition1]] | | [[condition2]] | Evaluate to True if either one of the conditions TRUE | | [ condition1 -a condition2 ] | Evaluate to True if both conditions are TRUE | | [ condition1 -o condition2 ] | Evaluate to True if either one of the conditions TRUE | \ud83d\udca1 Note: It is worth mentioning that you can replace all the double square brackets with single square brackets for example : `[[ NUM -eq NUM ]]` can also be written as `[ NUM -eq NUM ]` . This works with all the all conditions except for compound conditions which uses `-a` (AND) and `-o` (OR) as logical operators.","title":"Compound conditions"},{"location":"E_bash_conditions_and_flow_control.html#advanced-if-then-features","text":"Single parentheses (.......) allow you to use subshells in your if statement comparisons. The double parentheses (( epression )) command allows you to incorporate advanced mathematical formulas in your comparisons. check out performing arithmetic operations. The double bracket [[.......]] command provides advanced features for string comparisons.","title":"Advanced if-then Features"},{"location":"E_bash_options.html","text":"Bash options \u00b6 \ud83d\udca1 Options are settings that change shell or script behaviour. The `set` builtin command can be use to set options. There are two ways to set options either by `set -o option-name` or, in short form, `set -option-abbrev` ****. To disable **an option, use `set +o option-name` ****or `set +option-abbrev` ****. To enable option on a script on the command line use, `set +o option-name script-name` ****or ****`set option-abbrev script-name` | Abbreviation | Name | Effect | | -------------- | ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- | \u2014 | | -B | brace expansion | Enable brace expansion (default setting = on) | | +B | brace expansion | Disable brace expansion | | -C | noclobber | Prevent overwriting of files by redirection (but this may be overridden by > | ) | | -D | (none) | List double-quoted strings prefixed by $, but do not execute commands in script | | -a | allexport | Export all defined variables | | -b | notify | Notify when jobs running in background terminate (not of much use in a script) | | -c \u2026 | (none) | Read commands from \u2026 | | checkjobs | | Informs user of any open jobs upon shell exit. Introduced in version 4 of Bash, and still \u201cexperimental.\u201d Usage: shopt -s checkjobs (Caution: may hang!) | | -e | errexit | Abort script at first error, when a command exits with non-zero status (except in until or while loops, if-tests, list constructs) | | -f | noglob | Disable filename expansion (globbing) | | globstar | globbing star-match | Enables the ** globbing operator. Usage: shopt -s globstar | | -i | interactive | Runs a script in interactive mode | | -n | noexec | Read commands in script, but do not execute them (syntax check) | | -o Option-Name | (none) | Invoke the Option-Name option | | -o posix | POSIX | Change the behavior of Bash, or invoked script, to conform to POSIX standard. | | -o pipefail | pipe failure | Causes a pipeline to return the exit status of the last command in the pipe that returned a non-zero return value. | | -p | privileged | Script runs as \u201csuid\u201d (caution!) | | -r | restricted | Script runs in restricted mode | | -s | stdin | Read commands from stdin | | -t | onecmd | Exit after first command | | -u | nounset | Attempt to use undefined variable outputs error message, and forces an exit | | -v | verbose | Print each command to stdout before executing it | | -x | xtrace | Similar to -v, but expands commands | | - | (none) | End of options flag. All other arguments are positional parameters. | | \u2013 | (none) | Unset positional parameters. If arguments given (\u2013 arg1 arg2), positional parameters set to arguments. | \ud83d\udca1 [Read more about bash options](https://tldp.org/LDP/abs/html/options.html) [More about bash options here](https://wiki.bash-hackers.org/commands/builtin/set) Additional bash options \u00b6 Description \u00b6 \ud83d\udca1 The `shopt` builtin command allows you to change additional shell optional behavior. shopt options \u00b6 Option Description -o Restrict the values of to only those also known by the set builtin -p Print all shell options and their current value. Default. -q Quiet mode. Set exit code if named option is set. For multiple options: TRUE if all options are set, FALSE otherwise -s Enable (set) the shell options named by or list all enabled options if no names are given -u Disabe (unset) the shell options named by or list all disabled options if no names are given shopt syntax \u00b6 \ud83d\udee0 `shopt [-pqsu] [-o] ` \ud83d\udca1 According to the option table, if only -s or -u are specified without any option names, only the currently enabled (-s) or disabled (-u) options are printed. * *Exit code** \u00b6 \ud83d\udca1 When listing options, the exit code is `TRUE` (0), if all options are enabled, `FALSE` otherwise. When setting/unsetting an option, the exit code is `TRUE` unless the named option doesn't exitst. shopt -s nullglob #Example to enable nullglob option * *List of additional shell options** \u00b6 Option name Description autocd If set, a command name that is the name of a directory is executed as if it were the argument to the cd command. cdspell If set, minor errors in the spelling of a directory component in a cd command will be corrected. The errors checked for are transposed characters, a missing character, and one character too many. If a correction is found, the corrected file name is printed, and the command proceeds. checkjobs If set, Bash lists the status of any stopped and running jobs before exiting an interactive shell. If any jobs are running, this causes the exit to be deferred until a second exit is attempted without an intervening command. The shell always postpones exiting if any jobs are stopped. dirspell If set, Bash will perform spelling corrections on directory names to match a glob. dotglob If set, Bash includes filenames beginning with a . (dot) in the results of https://wiki.bash-hackers.org/syntax/expansion/globs. nullglob If set, Bash allows filename patterns which match no files to expand to a null string, rather than themselves. failglob If set, patterns which fail to match filenames during filename expansion result in an expansion error. nocaseglob If set, Bash matches filenames in a case-insensitive fashion when performing filename expansion. globstar If set, the pattern \u2018**\u2019 used in a filename expansion context will match all files and zero or more directories and subdirectories. If the pattern is followed by a \u2018/\u2019, only directories and subdirectories match. \ud83d\udca1 [Here is an exhaustive lists of all the additional options](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html)","title":"Bash options"},{"location":"E_bash_options.html#bash-options","text":"\ud83d\udca1 Options are settings that change shell or script behaviour. The `set` builtin command can be use to set options. There are two ways to set options either by `set -o option-name` or, in short form, `set -option-abbrev` ****. To disable **an option, use `set +o option-name` ****or `set +option-abbrev` ****. To enable option on a script on the command line use, `set +o option-name script-name` ****or ****`set option-abbrev script-name` | Abbreviation | Name | Effect | | -------------- | ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- | \u2014 | | -B | brace expansion | Enable brace expansion (default setting = on) | | +B | brace expansion | Disable brace expansion | | -C | noclobber | Prevent overwriting of files by redirection (but this may be overridden by > | ) | | -D | (none) | List double-quoted strings prefixed by $, but do not execute commands in script | | -a | allexport | Export all defined variables | | -b | notify | Notify when jobs running in background terminate (not of much use in a script) | | -c \u2026 | (none) | Read commands from \u2026 | | checkjobs | | Informs user of any open jobs upon shell exit. Introduced in version 4 of Bash, and still \u201cexperimental.\u201d Usage: shopt -s checkjobs (Caution: may hang!) | | -e | errexit | Abort script at first error, when a command exits with non-zero status (except in until or while loops, if-tests, list constructs) | | -f | noglob | Disable filename expansion (globbing) | | globstar | globbing star-match | Enables the ** globbing operator. Usage: shopt -s globstar | | -i | interactive | Runs a script in interactive mode | | -n | noexec | Read commands in script, but do not execute them (syntax check) | | -o Option-Name | (none) | Invoke the Option-Name option | | -o posix | POSIX | Change the behavior of Bash, or invoked script, to conform to POSIX standard. | | -o pipefail | pipe failure | Causes a pipeline to return the exit status of the last command in the pipe that returned a non-zero return value. | | -p | privileged | Script runs as \u201csuid\u201d (caution!) | | -r | restricted | Script runs in restricted mode | | -s | stdin | Read commands from stdin | | -t | onecmd | Exit after first command | | -u | nounset | Attempt to use undefined variable outputs error message, and forces an exit | | -v | verbose | Print each command to stdout before executing it | | -x | xtrace | Similar to -v, but expands commands | | - | (none) | End of options flag. All other arguments are positional parameters. | | \u2013 | (none) | Unset positional parameters. If arguments given (\u2013 arg1 arg2), positional parameters set to arguments. | \ud83d\udca1 [Read more about bash options](https://tldp.org/LDP/abs/html/options.html) [More about bash options here](https://wiki.bash-hackers.org/commands/builtin/set)","title":"Bash options"},{"location":"E_bash_options.html#additional-bash-options","text":"","title":"Additional bash options"},{"location":"E_bash_options.html#description","text":"\ud83d\udca1 The `shopt` builtin command allows you to change additional shell optional behavior.","title":"Description"},{"location":"E_bash_options.html#shopt-options","text":"Option Description -o Restrict the values of to only those also known by the set builtin -p Print all shell options and their current value. Default. -q Quiet mode. Set exit code if named option is set. For multiple options: TRUE if all options are set, FALSE otherwise -s Enable (set) the shell options named by or list all enabled options if no names are given -u Disabe (unset) the shell options named by or list all disabled options if no names are given","title":"shopt options"},{"location":"E_bash_options.html#shopt-syntax","text":"\ud83d\udee0 `shopt [-pqsu] [-o] ` \ud83d\udca1 According to the option table, if only -s or -u are specified without any option names, only the currently enabled (-s) or disabled (-u) options are printed.","title":"shopt syntax"},{"location":"E_bash_options.html#exit-code","text":"\ud83d\udca1 When listing options, the exit code is `TRUE` (0), if all options are enabled, `FALSE` otherwise. When setting/unsetting an option, the exit code is `TRUE` unless the named option doesn't exitst. shopt -s nullglob #Example to enable nullglob option","title":"**Exit code**"},{"location":"E_bash_options.html#list-of-additional-shell-options","text":"Option name Description autocd If set, a command name that is the name of a directory is executed as if it were the argument to the cd command. cdspell If set, minor errors in the spelling of a directory component in a cd command will be corrected. The errors checked for are transposed characters, a missing character, and one character too many. If a correction is found, the corrected file name is printed, and the command proceeds. checkjobs If set, Bash lists the status of any stopped and running jobs before exiting an interactive shell. If any jobs are running, this causes the exit to be deferred until a second exit is attempted without an intervening command. The shell always postpones exiting if any jobs are stopped. dirspell If set, Bash will perform spelling corrections on directory names to match a glob. dotglob If set, Bash includes filenames beginning with a . (dot) in the results of https://wiki.bash-hackers.org/syntax/expansion/globs. nullglob If set, Bash allows filename patterns which match no files to expand to a null string, rather than themselves. failglob If set, patterns which fail to match filenames during filename expansion result in an expansion error. nocaseglob If set, Bash matches filenames in a case-insensitive fashion when performing filename expansion. globstar If set, the pattern \u2018**\u2019 used in a filename expansion context will match all files and zero or more directories and subdirectories. If the pattern is followed by a \u2018/\u2019, only directories and subdirectories match. \ud83d\udca1 [Here is an exhaustive lists of all the additional options](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html)","title":"**List of additional shell options**"},{"location":"E_bash_redirections.html","text":"Bash redirections \u00b6 Standard file descriptors \u00b6 File Descriptor Abbreviation Description 0 STDIN Standard input, The input is read from what you type in the terminal using your keyboard. When you use the input redirect symbol (<), Linux substitutes the file referenced by the redirection for the standard input file descriptor. It reads the file and retrieves data in the same way that you would type it on a keyboard. 1 STDOUT Standard Output. The terminal monitor is the standard output on a terminal interface. All output from the shell (including programs and scripts run in the shell) is directed to the monitor\u2019s standard output. When you use the output redirect symbol (>), Linux replaces the terminal with a file referenced by the redirection symbol. 2 STDERR Standard Error. The STDERR file descriptor, by default, points to the same location as the STDOUT file descriptor (despite being assigned different file descriptor values). This means that by default, all error messages are displayed on the monitor. To redirect the errors you use a special redirection operator 2> . \ud83d\udca1 Unless they are closed, file descriptors always point to a file. When bash starts, all three file descriptors, stdin (file descriptor 0), stdout (file descriptor 1), and stderr (file descriptor 2), usually point to your terminal. You can also open and close additional file descriptors (such as 3, 4, 5,...). File descriptors can also be copied. You can also write to and read from them. Redirections Operators \u00b6 Redirection Description command > file Redirect the standard output (stdout) of a command to a specified file. This also the same as command 1> file , as 1 is the default file descriptor (fd) for standard output (stdout). command 2> file Redirect the standard error (stderr) of a command to a specified file. 2 is the default file descriptor (fd) for standard error (stderr). command >> file Redirect the standard output (stdout) of a command to a specified file without overriding the existing data. command 2>> file Redirect the standard error (stderrt) of a command to a specified file without overriding the existing data. command &> file Redirect both the standard output (stdout) and standard error (stderr) of a command to a file. This is also the same as command > file 2>&1 but command 2>&1 > file (the redirection order matters!) command > /dev/null Discard standard output (stdout) of a command. The /dev/null is a special file that discards all data written to it. command 2> /dev/null Discard standard error (stderr) of a command. command &> /dev/null Discard both the standard output (stdout) and the standard error (stderr) of a command. This also the same as command >/dev/null 2>&1. command < file Redirect the contents of the file to the standard input (stdin) of a command. This also the same as command 0< file . 0 is the default file descriptor (fd) for standard input (stdin). | command << EOL line1 line2 EOL | Redirect a bunch of lines to the standard input (stdin) of a command using the here-document redirection operator <<MARKER . This operator instructs bash to read the input from stdin until a line containing only MARKER is found. | | command <<- EOL foo bar EOL | Redirect a bunch of lines to the standard input (stdin) and strip the all leading tabs. Notice the difference (<<- ) | | command <<< \u2018string\u2019 command <<< $word | The here string is used for input redirection from a single line of text or a variable. A here string can be considered as a stripped-down form of here document | | command >| file | Overrides the noclobber shell option ( https://www.notion.so/e1b11cba3de54c4d8660ff30044e7310) | | exec 2> file | Redirect standard error of all commands to a file forever. | | exec > file | Redirect standard output of all commands to a file forever. | | exec 3< file | Create a custom file descriptor (3) for reading from a file | | exec 3> file | Create a custom file descriptor (3) for writing to a file | | exec 3<> file | Create a custom file descriptor (3) for both writing and reading a file | | exec 3>&- | Close the created file descriptor. | | exec 4<&3 | Make file descriptor 4 to be a copy of file descriptor 3. (Copy fd 3 to 4.) | | exec 4>&3- | Copy file descriptor 3 to 4 and close file descriptor 3. | | echo \u201cfoo\u201d >&3 | Write to a custom file descriptor 3. | | cat <&3 | Read from a custom file descriptor 3. | | exec 3<> /dev/tcp/host/port | Open a TCP connection to host:port. (This is a bash feature, not Linux feature). | | exec 3<> /dev/udp/host/port | Open a UDP connection to host:port. (This is a bash feature, not Linux feature). | | (command1; command2) > file | Redirect stdout from multiple commands to a file (using a sub-shell). The parenthesis instructs bash to create a subshell and run commands from there. | | { command1; command2 } > file | Redirect stdout from multiple commands to a file (This is faster as there is no need setting up a subshell environment to execute the commands). Notice the trailing and leading spaces between the curly braces and the commands. | | command <(command1) | Redirect stdout of command1 to an anonymous pipe fifo, then pass the fifo to command as an argument. Useful when command doesn\u2019t read from stdin directly. | | command < < (command1) | Redirect stdout of command to an anonymous pipe fifo, then redirect the fifo to stdin of command. Best example: diff <(find /path1 | sort) <(find /path2 | sort). | | command <(command1) <(command2) | Redirect stdout of command1 and command2 to two anonymous fifos, then pass both fifos as arguments to command. | | command1 >(command2) | Run command2 with its stdin connected to an anonymous fifo, and pass the filename of the pipe as an argument to command1. | | command1 > > (command2) | Run command2 with its stdin connected to an anonymous fifo, then redirect stdout of command1 to this anonymous pipe. | | command1 | command2 | Redirect stdout of command1 to stdin of command2. Pro-tip: This is the same as command1 > > (command2), same as cmd2 < <(cmd1), same as > >(cmd2) cmd1, same as < <(cmd1) cmd2. | | command1 |& command2 | Redirect stdout and stderr of command1 to stdin of command2 (bash 4.0+ only). Use command2>&1 | command2 for older bashes. | | commnad | tee file | Redirect stdout of commmand to a file and print it to screen. | | exec {filew}> file | Open a file for writing using a named file descriptor called {filew} (bash 4.1+). | | command 3>&1 1>&2 2>&3 | Swap stdout and stderr of command . | | cmd > >(cmd1) 2> >(cmd2) | Send stdout of cmd to cmd1 and stderr of cmd to cmd2. | | cmd1 | cmd2 | cmd3 | cmd4 echo ${PIPESTATUS[@]} | Find out the exit codes of all piped commands. | \ud83d\udca1 [Read this article for an explanation of each of this redirections](https://catonmat.net/bash-one-liners-explained-part-three) [The original cheatsheet for redirection operators can be found here:](https://catonmat.net/ftp/bash-redirections-cheat-sheet.pdf)","title":"Bash redirections"},{"location":"E_bash_redirections.html#bash-redirections","text":"","title":"Bash redirections"},{"location":"E_bash_redirections.html#standard-file-descriptors","text":"File Descriptor Abbreviation Description 0 STDIN Standard input, The input is read from what you type in the terminal using your keyboard. When you use the input redirect symbol (<), Linux substitutes the file referenced by the redirection for the standard input file descriptor. It reads the file and retrieves data in the same way that you would type it on a keyboard. 1 STDOUT Standard Output. The terminal monitor is the standard output on a terminal interface. All output from the shell (including programs and scripts run in the shell) is directed to the monitor\u2019s standard output. When you use the output redirect symbol (>), Linux replaces the terminal with a file referenced by the redirection symbol. 2 STDERR Standard Error. The STDERR file descriptor, by default, points to the same location as the STDOUT file descriptor (despite being assigned different file descriptor values). This means that by default, all error messages are displayed on the monitor. To redirect the errors you use a special redirection operator 2> . \ud83d\udca1 Unless they are closed, file descriptors always point to a file. When bash starts, all three file descriptors, stdin (file descriptor 0), stdout (file descriptor 1), and stderr (file descriptor 2), usually point to your terminal. You can also open and close additional file descriptors (such as 3, 4, 5,...). File descriptors can also be copied. You can also write to and read from them.","title":"Standard file descriptors"},{"location":"E_bash_redirections.html#redirections-operators","text":"Redirection Description command > file Redirect the standard output (stdout) of a command to a specified file. This also the same as command 1> file , as 1 is the default file descriptor (fd) for standard output (stdout). command 2> file Redirect the standard error (stderr) of a command to a specified file. 2 is the default file descriptor (fd) for standard error (stderr). command >> file Redirect the standard output (stdout) of a command to a specified file without overriding the existing data. command 2>> file Redirect the standard error (stderrt) of a command to a specified file without overriding the existing data. command &> file Redirect both the standard output (stdout) and standard error (stderr) of a command to a file. This is also the same as command > file 2>&1 but command 2>&1 > file (the redirection order matters!) command > /dev/null Discard standard output (stdout) of a command. The /dev/null is a special file that discards all data written to it. command 2> /dev/null Discard standard error (stderr) of a command. command &> /dev/null Discard both the standard output (stdout) and the standard error (stderr) of a command. This also the same as command >/dev/null 2>&1. command < file Redirect the contents of the file to the standard input (stdin) of a command. This also the same as command 0< file . 0 is the default file descriptor (fd) for standard input (stdin). | command << EOL line1 line2 EOL | Redirect a bunch of lines to the standard input (stdin) of a command using the here-document redirection operator <<MARKER . This operator instructs bash to read the input from stdin until a line containing only MARKER is found. | | command <<- EOL foo bar EOL | Redirect a bunch of lines to the standard input (stdin) and strip the all leading tabs. Notice the difference (<<- ) | | command <<< \u2018string\u2019 command <<< $word | The here string is used for input redirection from a single line of text or a variable. A here string can be considered as a stripped-down form of here document | | command >| file | Overrides the noclobber shell option ( https://www.notion.so/e1b11cba3de54c4d8660ff30044e7310) | | exec 2> file | Redirect standard error of all commands to a file forever. | | exec > file | Redirect standard output of all commands to a file forever. | | exec 3< file | Create a custom file descriptor (3) for reading from a file | | exec 3> file | Create a custom file descriptor (3) for writing to a file | | exec 3<> file | Create a custom file descriptor (3) for both writing and reading a file | | exec 3>&- | Close the created file descriptor. | | exec 4<&3 | Make file descriptor 4 to be a copy of file descriptor 3. (Copy fd 3 to 4.) | | exec 4>&3- | Copy file descriptor 3 to 4 and close file descriptor 3. | | echo \u201cfoo\u201d >&3 | Write to a custom file descriptor 3. | | cat <&3 | Read from a custom file descriptor 3. | | exec 3<> /dev/tcp/host/port | Open a TCP connection to host:port. (This is a bash feature, not Linux feature). | | exec 3<> /dev/udp/host/port | Open a UDP connection to host:port. (This is a bash feature, not Linux feature). | | (command1; command2) > file | Redirect stdout from multiple commands to a file (using a sub-shell). The parenthesis instructs bash to create a subshell and run commands from there. | | { command1; command2 } > file | Redirect stdout from multiple commands to a file (This is faster as there is no need setting up a subshell environment to execute the commands). Notice the trailing and leading spaces between the curly braces and the commands. | | command <(command1) | Redirect stdout of command1 to an anonymous pipe fifo, then pass the fifo to command as an argument. Useful when command doesn\u2019t read from stdin directly. | | command < < (command1) | Redirect stdout of command to an anonymous pipe fifo, then redirect the fifo to stdin of command. Best example: diff <(find /path1 | sort) <(find /path2 | sort). | | command <(command1) <(command2) | Redirect stdout of command1 and command2 to two anonymous fifos, then pass both fifos as arguments to command. | | command1 >(command2) | Run command2 with its stdin connected to an anonymous fifo, and pass the filename of the pipe as an argument to command1. | | command1 > > (command2) | Run command2 with its stdin connected to an anonymous fifo, then redirect stdout of command1 to this anonymous pipe. | | command1 | command2 | Redirect stdout of command1 to stdin of command2. Pro-tip: This is the same as command1 > > (command2), same as cmd2 < <(cmd1), same as > >(cmd2) cmd1, same as < <(cmd1) cmd2. | | command1 |& command2 | Redirect stdout and stderr of command1 to stdin of command2 (bash 4.0+ only). Use command2>&1 | command2 for older bashes. | | commnad | tee file | Redirect stdout of commmand to a file and print it to screen. | | exec {filew}> file | Open a file for writing using a named file descriptor called {filew} (bash 4.1+). | | command 3>&1 1>&2 2>&3 | Swap stdout and stderr of command . | | cmd > >(cmd1) 2> >(cmd2) | Send stdout of cmd to cmd1 and stderr of cmd to cmd2. | | cmd1 | cmd2 | cmd3 | cmd4 echo ${PIPESTATUS[@]} | Find out the exit codes of all piped commands. | \ud83d\udca1 [Read this article for an explanation of each of this redirections](https://catonmat.net/bash-one-liners-explained-part-three) [The original cheatsheet for redirection operators can be found here:](https://catonmat.net/ftp/bash-redirections-cheat-sheet.pdf)","title":"Redirections Operators"},{"location":"E_bash_regular_expression.html","text":"Regular expressions \u00b6 Types of regular expressions \u00b6 The POSIX Basic Regular Expression (BRE) The POSIX Extended Regular Expression (ERE) Anchors \u00b6 ^ Start of string, or start of line in multi-line pattern \\A Start of string $ End of string, or end of line in multi-line pattern \\Z End of string \\b Word boundary \\B Not word boundary \\< Start of word > End of word Character classes \u00b6 [abc] A single character of: a, b or c [^abc] A character except: a, b or c. The caret ^ negates character classes [a-z] A character in the range: a-z [^a-z] A character not in the range: a-z [0-9] A digit in the range: 0-9 [a-zA-Z] A character in the range:a-z or A-Z [a-zA-Z0-9] A character in the range:a-z, A-Z or 0-9 Shorthand character classes \u00b6 \\c Control character \\s White space \\S Not white space \\d Digit \\D Not digit \\w Word \\W Not word \\x Hexade\u00adcimal digit \\O Octal digit Posix BRE Special Character Classes \u00b6 | Class | Same as | Description | | ------------ | ------------------------------- | ----------------------------------------------------------------------------------------------------------------- | ------------------------------- | | [[:alnum:]] | [0-9A-Za-z] | Matches any alphanumeric character 0\u20139, A\u2013Z, or a\u2013z | | [[:alpha:]] | [A-Za-z] | Matches any alphabetical character, either upper or lower case | | [[:blank:]] | [\\t ] | Matches a space or Tab character | | [[:digit:]] | [0-9] | Matches a numerical digit from 0 through 9 | | [[:graph:]] | [[:alnum:][:punct:]] | Visible characters (not space) | | [[:lower:]] | [a-z] | Matches any lowercase alphabetical character a\u2013z | | [[:print:]] | [ -~] == [ [:graph:]] | Matches any printable character | | [[:punct:]] | [!\u201d#$%&\u2019()*+,-./:;<=>?@[]^_`{ | }~] | Matches a punctuation character | | [[:space:]] | [\\t\\n\\v\\f\\r ] | Matches any whitespace character: space, Tab, NL(newline), FF (formfeed), VT (vertical tab), CR (carriage return) | | [[:upper:]] | [A-Z] | Matches any uppercase alphabetical character A\u2013Z | | [[:word:]] | [0-9A-Za-z_] | Matches all world characters | | [[:xdigit:]] | [0-9A-Fa-f] | Matches all hexadecimal digits | | [[:<:]] | [\\b(?=\\w)] | Matches start of word | | [[:>:]] | [\\b(?<=\\w)] | Matches end of word | | [[:ascii:]] | [\\x00-\\x7F] | ASCII codes 0-127 | | [[:cntrl:]] | [\\x00-\\x1F\\x7F] | Control characters | Quantifiers \u00b6 ? Match an Element Zero or One Time * Match an Element Zero or More Times + Match an Element One or More Times [0-9]+ Any digit from 0-9 must appear 1 or more times. {} Match an Element a Specific Number of Times a{m} The character a must appear exactly m times. a{m,n} The character a must appear at least m times, but no more than n times. a{m,} The character a must appear m or more times. a* Greedy quantifier a*? Lazy quantifier a*+ Possessive quantifier {,n} Match the preceding element if it occurs no more than m times. \ud83d\udca1 **Common Meta-ch\u00adara\u00adcters** `^` `(` `{` `|` `*` ` < ` `$` `)` `?` `>` `.` `+` `[` `\\` Escape these special characters with `\\` Groups and ranges \u00b6 | . | Any character except new line (\\n) | | ------- | ---------------------------------- | ------ | | (a | b) | a or b | | (\u2026) | Group | | (?:\u2026) | Passive (non-c\u00adapt\u00aduring) group | | [abc] | Range (a or b or c) | | [^abc] | Not (a or b or c) | | [a-q] | Lower case letter from a to q | | [A-Q] | Upper case letter from A to Q | | [0-7] | Digit from 0 to 7 | | \\x | Group/\u00adsub\u00adpattern number \u201c\u00adx\u201d | Special Characters \u00b6 \\n Newline \\r Carriage return \\t Horizontal Tab \\v Vertical Tab \\f Form feed \\xxx Octal character xxx \\xhh Hex character hh Pattern Modifiers \u00b6 g Global match i * Case-i\u00adnse\u00adnsitive m * Multiple lines s * Treat string as single line x * Allow comments and whitespace in pattern e * Evaluate replac\u00adement U * Ungreedy pattern Escape sequences \u00b6 \\ Escape following character \\Q Begin literal sequence \\E End literal sequence \ud83d\udca1 What is Escaping? Escaping is a method of treating characters with special meanings in regular expressions literally rather than as special characters. Assertions \u00b6 | ?= | Lookahead assertion | | ---------- | ------------------------ | ------------------------ | | ?! | Negative lookahead | | ?<= | Lookbehind assertion | | ?!= or ?<! | Negative lookbehind | | ?> | Once-only Subexp\u00adression | | ?() | Condition [if then] | | ?() | | Condition [if then else] | | ?# | Comment | String replacement \u00b6 $n nth non-pa\u00adssive group $2 \u201c\u00adxyz\u00ad\u201d in /^(abc\u00ad(xy\u00adz))$/ $1 \u201c\u00adxyz\u00ad\u201d in /^(?:a\u00adbc)\u00ad(xyz)$/ $` Before matched string $\u2019 After matched string $+ Last matched string $& Entire matched string","title":"Regular expressions"},{"location":"E_bash_regular_expression.html#regular-expressions","text":"","title":"Regular expressions"},{"location":"E_bash_regular_expression.html#types-of-regular-expressions","text":"The POSIX Basic Regular Expression (BRE) The POSIX Extended Regular Expression (ERE)","title":"Types of regular expressions"},{"location":"E_bash_regular_expression.html#anchors","text":"^ Start of string, or start of line in multi-line pattern \\A Start of string $ End of string, or end of line in multi-line pattern \\Z End of string \\b Word boundary \\B Not word boundary \\< Start of word > End of word","title":"Anchors"},{"location":"E_bash_regular_expression.html#character-classes","text":"[abc] A single character of: a, b or c [^abc] A character except: a, b or c. The caret ^ negates character classes [a-z] A character in the range: a-z [^a-z] A character not in the range: a-z [0-9] A digit in the range: 0-9 [a-zA-Z] A character in the range:a-z or A-Z [a-zA-Z0-9] A character in the range:a-z, A-Z or 0-9","title":"Character classes"},{"location":"E_bash_regular_expression.html#shorthand-character-classes","text":"\\c Control character \\s White space \\S Not white space \\d Digit \\D Not digit \\w Word \\W Not word \\x Hexade\u00adcimal digit \\O Octal digit","title":"Shorthand character classes"},{"location":"E_bash_regular_expression.html#posix-bre-special-character-classes","text":"| Class | Same as | Description | | ------------ | ------------------------------- | ----------------------------------------------------------------------------------------------------------------- | ------------------------------- | | [[:alnum:]] | [0-9A-Za-z] | Matches any alphanumeric character 0\u20139, A\u2013Z, or a\u2013z | | [[:alpha:]] | [A-Za-z] | Matches any alphabetical character, either upper or lower case | | [[:blank:]] | [\\t ] | Matches a space or Tab character | | [[:digit:]] | [0-9] | Matches a numerical digit from 0 through 9 | | [[:graph:]] | [[:alnum:][:punct:]] | Visible characters (not space) | | [[:lower:]] | [a-z] | Matches any lowercase alphabetical character a\u2013z | | [[:print:]] | [ -~] == [ [:graph:]] | Matches any printable character | | [[:punct:]] | [!\u201d#$%&\u2019()*+,-./:;<=>?@[]^_`{ | }~] | Matches a punctuation character | | [[:space:]] | [\\t\\n\\v\\f\\r ] | Matches any whitespace character: space, Tab, NL(newline), FF (formfeed), VT (vertical tab), CR (carriage return) | | [[:upper:]] | [A-Z] | Matches any uppercase alphabetical character A\u2013Z | | [[:word:]] | [0-9A-Za-z_] | Matches all world characters | | [[:xdigit:]] | [0-9A-Fa-f] | Matches all hexadecimal digits | | [[:<:]] | [\\b(?=\\w)] | Matches start of word | | [[:>:]] | [\\b(?<=\\w)] | Matches end of word | | [[:ascii:]] | [\\x00-\\x7F] | ASCII codes 0-127 | | [[:cntrl:]] | [\\x00-\\x1F\\x7F] | Control characters |","title":"Posix BRE Special Character Classes"},{"location":"E_bash_regular_expression.html#quantifiers","text":"? Match an Element Zero or One Time * Match an Element Zero or More Times + Match an Element One or More Times [0-9]+ Any digit from 0-9 must appear 1 or more times. {} Match an Element a Specific Number of Times a{m} The character a must appear exactly m times. a{m,n} The character a must appear at least m times, but no more than n times. a{m,} The character a must appear m or more times. a* Greedy quantifier a*? Lazy quantifier a*+ Possessive quantifier {,n} Match the preceding element if it occurs no more than m times. \ud83d\udca1 **Common Meta-ch\u00adara\u00adcters** `^` `(` `{` `|` `*` ` < ` `$` `)` `?` `>` `.` `+` `[` `\\` Escape these special characters with `\\`","title":"Quantifiers"},{"location":"E_bash_regular_expression.html#groups-and-ranges","text":"| . | Any character except new line (\\n) | | ------- | ---------------------------------- | ------ | | (a | b) | a or b | | (\u2026) | Group | | (?:\u2026) | Passive (non-c\u00adapt\u00aduring) group | | [abc] | Range (a or b or c) | | [^abc] | Not (a or b or c) | | [a-q] | Lower case letter from a to q | | [A-Q] | Upper case letter from A to Q | | [0-7] | Digit from 0 to 7 | | \\x | Group/\u00adsub\u00adpattern number \u201c\u00adx\u201d |","title":"Groups and ranges"},{"location":"E_bash_regular_expression.html#special-characters","text":"\\n Newline \\r Carriage return \\t Horizontal Tab \\v Vertical Tab \\f Form feed \\xxx Octal character xxx \\xhh Hex character hh","title":"Special Characters"},{"location":"E_bash_regular_expression.html#pattern-modifiers","text":"g Global match i * Case-i\u00adnse\u00adnsitive m * Multiple lines s * Treat string as single line x * Allow comments and whitespace in pattern e * Evaluate replac\u00adement U * Ungreedy pattern","title":"Pattern Modifiers"},{"location":"E_bash_regular_expression.html#escape-sequences","text":"\\ Escape following character \\Q Begin literal sequence \\E End literal sequence \ud83d\udca1 What is Escaping? Escaping is a method of treating characters with special meanings in regular expressions literally rather than as special characters.","title":"Escape sequences"},{"location":"E_bash_regular_expression.html#assertions","text":"| ?= | Lookahead assertion | | ---------- | ------------------------ | ------------------------ | | ?! | Negative lookahead | | ?<= | Lookbehind assertion | | ?!= or ?<! | Negative lookbehind | | ?> | Once-only Subexp\u00adression | | ?() | Condition [if then] | | ?() | | Condition [if then else] | | ?# | Comment |","title":"Assertions"},{"location":"E_bash_regular_expression.html#string-replacement","text":"$n nth non-pa\u00adssive group $2 \u201c\u00adxyz\u00ad\u201d in /^(abc\u00ad(xy\u00adz))$/ $1 \u201c\u00adxyz\u00ad\u201d in /^(?:a\u00adbc)\u00ad(xyz)$/ $` Before matched string $\u2019 After matched string $+ Last matched string $& Entire matched string","title":"String replacement"},{"location":"bash_built_in_commands.html","text":"Bash built-in commands \u00b6 * *Shell Builtins** \u00b6 Built-in commands are distinct in that they do not require the execution of a child process. They were compiled into the shell and thus become part of its toolkit. There is no external program file to run them. Bash Built\u2010In Commands #-B \u00b6 Command Description . same as source builtin. Reads and executes commands from a designated file in the current shell & Starts a job in background mode ((x)) Evaluates the x mathematical expression not: Reads and executes commands from a designated file in the current shell. : Does nothing, and always exits successfully, same as true builtin [ t ] Evaluates the t conditional expression [[e]] Evaluates the e conditional expression alias Defines an alias for the specified command bg Resumes a job in background mode bind Binds a keyboard sequence to a readline function or macro break Exits from a for , while , select , or until loop builtin Executes the specified shell built\u2010in command Bash Built\u2010In Commands C-D \u00b6 caller Returns the context of any active subroutine call case Selectively executes commands based on pattern cd Changes the current directory to the specified directory command Executes the specified command without the normal shell lookup compgen Generates possible completion matches for the specified word complete Displays how the specified words would be completed compopt Changes options for how the specified words would be completed continue Resumes the next iteration of a for , while , select , or until loop coproc Executes a coprocess declare Declares a variable or variable type dirs Displays a list of currently remembered directories disown Removes the specified jobs from the jobs table for the process Bash Built\u2010In Commands E-F \u00b6 echo Displays the specified string to STDOUT enable Enables or disables the specified built\u2010in shell command eval Concatenates the specified arguments into a single command, and executes the command exec Replaces the shell process with the specified command exit Forces the shell to exit with the specified exit status export Sets the specified variables to be available for child shell processes false Sets a result to failed status fc Selects a list of commands from the history list fg Resumes a job in foreground mode for Executes set commands for every item in the list function Defines a shell script function Bash Built\u2010In Commands G-P \u00b6 getopts Parses the specified positional parameters hash Finds and remembers the full pathname of the specified command help Displays a help file history Displays the command history if Executes set commands based on conditional expression jobs Lists the active jobs kill Sends a system signal to the specified process ID (PID) let Evaluates each argument in a mathematical expression local Creates a limited\u2010scope variable in a function logout Exits a login shell mapfile Reads STDIN lines and puts them into an indexed array popd Removes entries from the directory stack printf Displays text using formatted strings pushd Adds a directory to the directory stack pwd Displays the pathname of the current working directory Bash Built\u2010In Commands R- \u00b6 read Reads one line of data from STDIN , and assigns it to a variable readarray Reads STDIN lines, and puts them into an indexed array readonly Reads one line of data from STDIN , and assigns it to a variable that can\u2019t be changed return Forces a function to exit with a value that can be retrieved by the calling script select Displays list of words with numbers allowing selection set Sets and displays environment variable values and shell attributes shift Rotates positional parameters down one position shopt Toggles the values of variables controlling optional shell behavior source Reads and executes commands from a designated file in the current shell suspend Suspends the execution of the shell until a SIGCONT signal is received test Returns an exit status of 0 or 1 based on the specified condition time Displays the accumulated real, user, and system times executing command(s) times Displays the accumulated user and system shell times trap Executes the specified command if the specified system signal is received true Sets a result to successful status type Displays how the specified word would be interpreted if used as a command typeset Declares a variable or variable type ulimit Sets a limit on the specified resource for system users umask Sets default permissions for newly created files and directories unalias Removes the specified alias unset Removes the specified environment variable or shell attribute until Executes set commands until condition statement returns true wait Waits for the specified process to complete, and returns the exit status while Executes set commands while condition statement returns true { c; } Group commands to execute within current shell","title":"Bash built-in commands"},{"location":"bash_built_in_commands.html#bash-built-in-commands","text":"","title":"Bash built-in commands"},{"location":"bash_built_in_commands.html#shell-builtins","text":"Built-in commands are distinct in that they do not require the execution of a child process. They were compiled into the shell and thus become part of its toolkit. There is no external program file to run them.","title":"**Shell Builtins**"},{"location":"bash_built_in_commands.html#bash-builtin-commands-b","text":"Command Description . same as source builtin. Reads and executes commands from a designated file in the current shell & Starts a job in background mode ((x)) Evaluates the x mathematical expression not: Reads and executes commands from a designated file in the current shell. : Does nothing, and always exits successfully, same as true builtin [ t ] Evaluates the t conditional expression [[e]] Evaluates the e conditional expression alias Defines an alias for the specified command bg Resumes a job in background mode bind Binds a keyboard sequence to a readline function or macro break Exits from a for , while , select , or until loop builtin Executes the specified shell built\u2010in command","title":"Bash Built\u2010In Commands #-B"},{"location":"bash_built_in_commands.html#bash-builtin-commands-c-d","text":"caller Returns the context of any active subroutine call case Selectively executes commands based on pattern cd Changes the current directory to the specified directory command Executes the specified command without the normal shell lookup compgen Generates possible completion matches for the specified word complete Displays how the specified words would be completed compopt Changes options for how the specified words would be completed continue Resumes the next iteration of a for , while , select , or until loop coproc Executes a coprocess declare Declares a variable or variable type dirs Displays a list of currently remembered directories disown Removes the specified jobs from the jobs table for the process","title":"Bash Built\u2010In Commands C-D"},{"location":"bash_built_in_commands.html#bash-builtin-commands-e-f","text":"echo Displays the specified string to STDOUT enable Enables or disables the specified built\u2010in shell command eval Concatenates the specified arguments into a single command, and executes the command exec Replaces the shell process with the specified command exit Forces the shell to exit with the specified exit status export Sets the specified variables to be available for child shell processes false Sets a result to failed status fc Selects a list of commands from the history list fg Resumes a job in foreground mode for Executes set commands for every item in the list function Defines a shell script function","title":"Bash Built\u2010In Commands E-F"},{"location":"bash_built_in_commands.html#bash-builtin-commands-g-p","text":"getopts Parses the specified positional parameters hash Finds and remembers the full pathname of the specified command help Displays a help file history Displays the command history if Executes set commands based on conditional expression jobs Lists the active jobs kill Sends a system signal to the specified process ID (PID) let Evaluates each argument in a mathematical expression local Creates a limited\u2010scope variable in a function logout Exits a login shell mapfile Reads STDIN lines and puts them into an indexed array popd Removes entries from the directory stack printf Displays text using formatted strings pushd Adds a directory to the directory stack pwd Displays the pathname of the current working directory","title":"Bash Built\u2010In Commands G-P"},{"location":"bash_built_in_commands.html#bash-builtin-commands-r-","text":"read Reads one line of data from STDIN , and assigns it to a variable readarray Reads STDIN lines, and puts them into an indexed array readonly Reads one line of data from STDIN , and assigns it to a variable that can\u2019t be changed return Forces a function to exit with a value that can be retrieved by the calling script select Displays list of words with numbers allowing selection set Sets and displays environment variable values and shell attributes shift Rotates positional parameters down one position shopt Toggles the values of variables controlling optional shell behavior source Reads and executes commands from a designated file in the current shell suspend Suspends the execution of the shell until a SIGCONT signal is received test Returns an exit status of 0 or 1 based on the specified condition time Displays the accumulated real, user, and system times executing command(s) times Displays the accumulated user and system shell times trap Executes the specified command if the specified system signal is received true Sets a result to successful status type Displays how the specified word would be interpreted if used as a command typeset Declares a variable or variable type ulimit Sets a limit on the specified resource for system users umask Sets default permissions for newly created files and directories unalias Removes the specified alias unset Removes the specified environment variable or shell attribute until Executes set commands until condition statement returns true wait Waits for the specified process to complete, and returns the exit status while Executes set commands while condition statement returns true { c; } Group commands to execute within current shell","title":"Bash Built\u2010In Commands R-"},{"location":"bash_functions.html","text":"Bash functions \u00b6 Defining functions \u00b6 greet () { echo \"hello $1 $2 \" } # Same as above (alternate syntax) function greet () { echo \"hello $1 $2 \" } # Calling the function greet \"John\" \"Paul\" Returning values \u00b6 add_numbers () { # perfoming mathematical additions local result = $(( $1 + $2 ) # returning the sresult value echo $result } # storing the returned value result = \" $( add_numbers 1 2 ) \" Raising errors \u00b6 # using return myfunc () { return 1 } if myfunc ; then echo \"success\" else echo \"failure\" fi","title":"Bash functions"},{"location":"bash_functions.html#bash-functions","text":"","title":"Bash functions"},{"location":"bash_functions.html#defining-functions","text":"greet () { echo \"hello $1 $2 \" } # Same as above (alternate syntax) function greet () { echo \"hello $1 $2 \" } # Calling the function greet \"John\" \"Paul\"","title":"Defining functions"},{"location":"bash_functions.html#returning-values","text":"add_numbers () { # perfoming mathematical additions local result = $(( $1 + $2 ) # returning the sresult value echo $result } # storing the returned value result = \" $( add_numbers 1 2 ) \"","title":"Returning values"},{"location":"bash_functions.html#raising-errors","text":"# using return myfunc () { return 1 } if myfunc ; then echo \"success\" else echo \"failure\" fi","title":"Raising errors"},{"location":"bash_getting_started.html","text":"Getting started \u00b6 Variables \u00b6 NAME = \"Bob\" echo ${ NAME } # => Bob :This prints the variable value echo $NAME # => Bob :This prints the variable value echo \" $NAME \" # => Bob :This prints the variable value echo '$NAME' # => $NAME : This will print the Exact string not value. echo \" ${ NAME } !\" # => Bob! :Concatenation of variable value with ! # Note: When declaring variables there should be no spaces between the variable # name and equal sign and between the equal sign and the variable value. # this will throw and error NAME = \"Bob\" # => Error (about space) \ud83d\udca1 It is crucial to keep in mind that when referencing a variable value, the dollar sign is used, but when referencing the variable to assign a value, the dollar sign is not used. Comments \u00b6 # This is an inline Bash comment. : ' This is a Multi-line comment in bash If it looks very neat ' # **Note you can replace the single quoations with** # **double qoutations** \ud83d\udca1 For Multi-line comments use `:'` to open and `'` to close. Functions \u00b6 #!/usr/bin/env bash get_username () { echo \"Bob\" } # Or using the function keyword function get_username () { echo \"Bob\" } echo \"You are $( get_username ) \" Brace Expansion \u00b6 Example Description $ echo {A,B}.txt output will be A.txt and B.txt {A,B} Same as A B {1..5} Same as 1 2 3 4 5 \ud83d\udd17 [Learn more about brace expansion here:](https://wiki.bash-hackers.org/syntax/expansion/brace) Special parameters \u00b6 Parameter Description $1\u2026 $9 Parameters 1 to 9. $0 Stores the name of the script file or the current shell name. $1 represents the first argument. ${10} Positional parameter 10. $# Number of positional parameters $* stores all the arguments. $$ Process id of the current shell. $@ All arguments, starting from first. $- Current options. $_ Last argument of the previous command $! The process ID (PID) of the most recently executed background pipeline (like started with command &) $? Status of the most recently executed foreground-pipeline (exit/return code) \ud83d\udd17 [Learn more about special parameters here:](https://wiki.bash-hackers.org/syntax/shellvars#special_parameters_and_shell_variables) Example script \u00b6 #!/usr/bin/env bash greet = \"world World\" echo \" $greet !, I'm new here.\" # => Hello world! I'm new here. #Execute the script $ chmod +x helloworld.sh $ ./helloworld.sh # or just $ bash helloworld.sh Conditions \u00b6 #!/usr/bin/env bash string = \"test\" if [[ -z \" $string \" ]] ; then echo \"String is empty\" elif [[ -n \" $string \" ]] ; then echo \"String is not empty\" fi Command Substitution \u00b6 # => I'm Bob echo \"I'm $( whoami ) \" # Similar to: echo \"I'm `whoami`\" \ud83d\udd17 [Learn more about command substitution here:](https://wiki.bash-hackers.org/syntax/expansion/cmdsubst)","title":"Getting started"},{"location":"bash_getting_started.html#getting-started","text":"","title":"Getting started"},{"location":"bash_getting_started.html#variables","text":"NAME = \"Bob\" echo ${ NAME } # => Bob :This prints the variable value echo $NAME # => Bob :This prints the variable value echo \" $NAME \" # => Bob :This prints the variable value echo '$NAME' # => $NAME : This will print the Exact string not value. echo \" ${ NAME } !\" # => Bob! :Concatenation of variable value with ! # Note: When declaring variables there should be no spaces between the variable # name and equal sign and between the equal sign and the variable value. # this will throw and error NAME = \"Bob\" # => Error (about space) \ud83d\udca1 It is crucial to keep in mind that when referencing a variable value, the dollar sign is used, but when referencing the variable to assign a value, the dollar sign is not used.","title":"Variables"},{"location":"bash_getting_started.html#comments","text":"# This is an inline Bash comment. : ' This is a Multi-line comment in bash If it looks very neat ' # **Note you can replace the single quoations with** # **double qoutations** \ud83d\udca1 For Multi-line comments use `:'` to open and `'` to close.","title":"Comments"},{"location":"bash_getting_started.html#functions","text":"#!/usr/bin/env bash get_username () { echo \"Bob\" } # Or using the function keyword function get_username () { echo \"Bob\" } echo \"You are $( get_username ) \"","title":"Functions"},{"location":"bash_getting_started.html#brace-expansion","text":"Example Description $ echo {A,B}.txt output will be A.txt and B.txt {A,B} Same as A B {1..5} Same as 1 2 3 4 5 \ud83d\udd17 [Learn more about brace expansion here:](https://wiki.bash-hackers.org/syntax/expansion/brace)","title":"Brace Expansion"},{"location":"bash_getting_started.html#special-parameters","text":"Parameter Description $1\u2026 $9 Parameters 1 to 9. $0 Stores the name of the script file or the current shell name. $1 represents the first argument. ${10} Positional parameter 10. $# Number of positional parameters $* stores all the arguments. $$ Process id of the current shell. $@ All arguments, starting from first. $- Current options. $_ Last argument of the previous command $! The process ID (PID) of the most recently executed background pipeline (like started with command &) $? Status of the most recently executed foreground-pipeline (exit/return code) \ud83d\udd17 [Learn more about special parameters here:](https://wiki.bash-hackers.org/syntax/shellvars#special_parameters_and_shell_variables)","title":"Special parameters"},{"location":"bash_getting_started.html#example-script","text":"#!/usr/bin/env bash greet = \"world World\" echo \" $greet !, I'm new here.\" # => Hello world! I'm new here. #Execute the script $ chmod +x helloworld.sh $ ./helloworld.sh # or just $ bash helloworld.sh","title":"Example script"},{"location":"bash_getting_started.html#conditions","text":"#!/usr/bin/env bash string = \"test\" if [[ -z \" $string \" ]] ; then echo \"String is empty\" elif [[ -n \" $string \" ]] ; then echo \"String is not empty\" fi","title":"Conditions"},{"location":"bash_getting_started.html#command-substitution","text":"# => I'm Bob echo \"I'm $( whoami ) \" # Similar to: echo \"I'm `whoami`\" \ud83d\udd17 [Learn more about command substitution here:](https://wiki.bash-hackers.org/syntax/expansion/cmdsubst)","title":"Command Substitution"},{"location":"bash_history.html","text":"Bash history \u00b6 History commands \u00b6 Command Description history Display history history n Display only the last n commands from the history history -c Clears your current history and starts adding commands from scratch history -d n Delete the specified nth command from history sudo !! Run the previous command with sudo command Prevent history from adding the command to history shopt -s histverify Don\u2019t execute expanded result immediately echo $HISTSIZE Display maximum of commands that can be stored in history file History modifiers \u00b6 Modifiers Description :h Remove a trailing file name component, leaving only the head from the expanded command. :r Remove a trailing suffix of the form .xxx, leaving the basename. :t Remove all leading file name components, leaving the tail. :e Remove all but the trailing suffix. :p Print the new command but do not execute it. :q Quote the substituted words, escaping further substitutions. :x Quote the substituted words as with q, but break into words at blanks and newlines. The q and x modifiers are mutually exclusive; the last one supplied is used. :s/old/new/ Substitute new for the first occurrence of old in the event line. :gs/old/new/ Cause changes to be applied over the entire event line. This is used in conjunction with :s\u2019 :& Repeat the previous substitution. :G Apply the following s\u2019 or &\u2019 modifier once to each word in the event line. History slices \u00b6 Slices Description !!:n Expand only nth token from most recent command (command is 0; first argument is 1) !^ Expand first argument from most recent command !$ Expand last token from most recent command !!:n-m Expand range of tokens from most recent command !!:n-$ Expand nth token to last from most recent command History event designators \u00b6 Event Description !! Expand the previous command !-n Expand nth most recent command !n Expand nth command in history ! Expand most recent invocation of command ! Expand the last command that begins with a specific text !n:p or ! :p Print the expanded command before executing it. string1 string2 Expand the last command, replacing string1 with string2. !# Expand the entire command line typed so far. History Word designators \u00b6 \ud83d\udca1 Word designators are used to select desired words from the event. A colon \u201c:\u201d separates the event specification from the word designator. Here are some word designators (^, $, *, -, or %) Word Description !$ Expand last parameter of most recent command !* Expand all parameters of most recent command !^ Expand the first parameter of the most recent command !n Expand nth command in history !% The first word matched by the most recent `?string?\u2019 search, if the search string begins with a character that is part of a word. !x-y A range of words; -y abbreviates 0-y \ud83d\udca1 Following the optional word designator, one or more of the modifiers listed on the left side may appear, each preceded by a ':'. These change or edit the word or words chosen from the history event. **Remove a trailing file name component, leaving only the head from the expanded command.** `$ cat demo.sh` `$ $!:h:p` #\u21d2 this will print demo","title":"Bash history"},{"location":"bash_history.html#bash-history","text":"","title":"Bash history"},{"location":"bash_history.html#history-commands","text":"Command Description history Display history history n Display only the last n commands from the history history -c Clears your current history and starts adding commands from scratch history -d n Delete the specified nth command from history sudo !! Run the previous command with sudo command Prevent history from adding the command to history shopt -s histverify Don\u2019t execute expanded result immediately echo $HISTSIZE Display maximum of commands that can be stored in history file","title":"History commands"},{"location":"bash_history.html#history-modifiers","text":"Modifiers Description :h Remove a trailing file name component, leaving only the head from the expanded command. :r Remove a trailing suffix of the form .xxx, leaving the basename. :t Remove all leading file name components, leaving the tail. :e Remove all but the trailing suffix. :p Print the new command but do not execute it. :q Quote the substituted words, escaping further substitutions. :x Quote the substituted words as with q, but break into words at blanks and newlines. The q and x modifiers are mutually exclusive; the last one supplied is used. :s/old/new/ Substitute new for the first occurrence of old in the event line. :gs/old/new/ Cause changes to be applied over the entire event line. This is used in conjunction with :s\u2019 :& Repeat the previous substitution. :G Apply the following s\u2019 or &\u2019 modifier once to each word in the event line.","title":"History modifiers"},{"location":"bash_history.html#history-slices","text":"Slices Description !!:n Expand only nth token from most recent command (command is 0; first argument is 1) !^ Expand first argument from most recent command !$ Expand last token from most recent command !!:n-m Expand range of tokens from most recent command !!:n-$ Expand nth token to last from most recent command","title":"History slices"},{"location":"bash_history.html#history-event-designators","text":"Event Description !! Expand the previous command !-n Expand nth most recent command !n Expand nth command in history ! Expand most recent invocation of command ! Expand the last command that begins with a specific text !n:p or ! :p Print the expanded command before executing it. string1 string2 Expand the last command, replacing string1 with string2. !# Expand the entire command line typed so far.","title":"History event designators"},{"location":"bash_history.html#history-word-designators","text":"\ud83d\udca1 Word designators are used to select desired words from the event. A colon \u201c:\u201d separates the event specification from the word designator. Here are some word designators (^, $, *, -, or %) Word Description !$ Expand last parameter of most recent command !* Expand all parameters of most recent command !^ Expand the first parameter of the most recent command !n Expand nth command in history !% The first word matched by the most recent `?string?\u2019 search, if the search string begins with a character that is part of a word. !x-y A range of words; -y abbreviates 0-y \ud83d\udca1 Following the optional word designator, one or more of the modifiers listed on the left side may appear, each preceded by a ':'. These change or edit the word or words chosen from the history event. **Remove a trailing file name component, leaving only the head from the expanded command.** `$ cat demo.sh` `$ $!:h:p` #\u21d2 this will print demo","title":"History Word designators"},{"location":"bash_loops.html","text":"Bash loops \u00b6 Bash for loop \u00b6 for i in /etc/* ; do echo $i done # Same as above(alternate syntax), also works with other loop structs for i in /etc/* do echo $i done Bash while loop \u00b6 # incrementing the value i = 1 while [[ $i -lt 4 ]] ; do echo \"Number: $i \" (( i++ )) done # decrementing the value i = 3 while [[ $i -gt 0 ]] ; do echo \"Number: $i \" (( i-- )) done Continue statement \u00b6 # seq command can be using to gerate ranges for number in $( seq 1 3 ) ; do if [[ $number == 2 ]] ; then continue ; fi echo \" $number \" done C-like for loop \u00b6 for (( i = 0 ; i < 100 ; i++ )) ; do echo $i done # Same as above (alternate syntax) also works with other loop structs for (( i = 0 ; i < 100 ; i++ )) do echo $i done Bash while True loop \u00b6 # while true long hand while true ; do # TODO # TODO done # or the shorthand (alternate syntax) while : ; do # TODO # TODO done Break statement \u00b6 ` for number in $( seq 1 3 ) ; do if [[ $number == 2 ]] ; then # Skip entire rest of loop or break out of the loop. break ; fi # This will only print 1 echo \" $number \" done Ranges \u00b6 for i in { 1 ..10 } ; do echo \"Number: $i \" done # With step size # => {START..STOP..STEP} for i in { 5 ..50..5 } ; do echo \"Number: $i \" done Reading files with while loop \u00b6 # using pipes cat file.txt | while read line ; do echo $line done # OR using input redirection while read line ; do echo $line done < \"/path/to/txt/file\" Until or do loop \u00b6 # incrementing count = 0 until [ $count -gt 10 ] ; do echo \" $count \" (( count++ )) done # decremetning count = 10 until [ $count -eq 0 ] ; do echo \" $count \" (( count-- )) done","title":"Bash loops"},{"location":"bash_loops.html#bash-loops","text":"","title":"Bash loops"},{"location":"bash_loops.html#bash-for-loop","text":"for i in /etc/* ; do echo $i done # Same as above(alternate syntax), also works with other loop structs for i in /etc/* do echo $i done","title":"Bash for loop"},{"location":"bash_loops.html#bash-while-loop","text":"# incrementing the value i = 1 while [[ $i -lt 4 ]] ; do echo \"Number: $i \" (( i++ )) done # decrementing the value i = 3 while [[ $i -gt 0 ]] ; do echo \"Number: $i \" (( i-- )) done","title":"Bash while loop"},{"location":"bash_loops.html#continue-statement","text":"# seq command can be using to gerate ranges for number in $( seq 1 3 ) ; do if [[ $number == 2 ]] ; then continue ; fi echo \" $number \" done","title":"Continue statement"},{"location":"bash_loops.html#c-like-for-loop","text":"for (( i = 0 ; i < 100 ; i++ )) ; do echo $i done # Same as above (alternate syntax) also works with other loop structs for (( i = 0 ; i < 100 ; i++ )) do echo $i done","title":"C-like for loop"},{"location":"bash_loops.html#bash-while-true-loop","text":"# while true long hand while true ; do # TODO # TODO done # or the shorthand (alternate syntax) while : ; do # TODO # TODO done","title":"Bash while True loop"},{"location":"bash_loops.html#break-statement","text":"` for number in $( seq 1 3 ) ; do if [[ $number == 2 ]] ; then # Skip entire rest of loop or break out of the loop. break ; fi # This will only print 1 echo \" $number \" done","title":"Break statement"},{"location":"bash_loops.html#ranges","text":"for i in { 1 ..10 } ; do echo \"Number: $i \" done # With step size # => {START..STOP..STEP} for i in { 5 ..50..5 } ; do echo \"Number: $i \" done","title":"Ranges"},{"location":"bash_loops.html#reading-files-with-while-loop","text":"# using pipes cat file.txt | while read line ; do echo $line done # OR using input redirection while read line ; do echo $line done < \"/path/to/txt/file\"","title":"Reading files with while loop"},{"location":"bash_loops.html#until-or-do-loop","text":"# incrementing count = 0 until [ $count -gt 10 ] ; do echo \" $count \" (( count++ )) done # decremetning count = 10 until [ $count -eq 0 ] ; do echo \" $count \" (( count-- )) done","title":"Until or do loop"},{"location":"bash_parameter_expansion.html","text":"Bash parameter expansion \u00b6 Syntax \u00b6 Syntax Description ${parameter%suffix} Remove suffix ${parameter#prefix} Remove prefix ${parameter%%suffix} Remove long suffix ${parameter##prefix} Remove long prefix ${parameter/pattern/string} Replace first pattern match with string ${parameter//pattern/string} Replace all the pattern with string ${parameter/%pattern/string} Replace suffix pattern with string ${parameter/#pattern/string} Replace prefix patter with string Substrings \u00b6 ${FOO:0:3} Substring (position, length) ${FOO:(-3):3} Substring from the right Length \u00b6 ${#FOO} Length of $FOO Default values \u00b6 ${FOO:-val} $FOO, or val if unset ${FOO:=val} Set $FOO to val if unset ${FOO:+val} val if $FOO is set ${FOO:?message} Show message and exit if $FOO is unset Substitution \u00b6 echo ${ food :- Cake } #=> $food or \"Cake\" STR = \"/path/to/foo.cpp\" echo ${ STR %.cpp } # /path/to/foo echo ${ STR %.cpp } .o # /path/to/foo.o echo ${ STR %/* } # /path/to echo ${ STR ##*. } # cpp (extension) echo ${ STR ##*/ } # foo.cpp (basepath) echo ${ STR #*/ } # path/to/foo.cpp echo ${ STR ##*/ } # foo.cpp echo ${ STR /foo/bar } # /path/to/bar.cpp B**asepath & Dirpath** \u00b6 SRC = \"/path/to/foo.cpp\" BASEPATH = ${ SRC ##*/ } echo $BASEPATH # => \"foo.cpp\" DIRPATH = ${ SRC % $BASEPATH } echo $DIRPATH # => \"/path/to/\" Slicing \u00b6 name = \"John\" echo ${ name } # => John echo ${ name : 0 : 2 } # => Jo echo ${ name :: 2 } # => Jo echo ${ name : :- 1 } # => Joh echo ${ name :(-1) } # => n echo ${ name :(-2) } # => hn echo ${ name :(-2): 2 } # => hn length = 2 echo ${ name : 0 : length } # => Jo Transform \u00b6 STR = \"HELLO WORLD!\" echo ${ STR , } # => hELLO WORLD! echo ${ STR ,, } # => hello world! STR = \"hello world!\" echo ${ STR ^ } # => Hello world! echo ${ STR ^^ } # => HELLO WORLD! ARR =( hello World ) echo \" ${ ARR [@], } \" # => hello world echo \" ${ ARR [@]^ } \" # => Hello World \ud83d\udca1 Read more about bash parameter expansions here:","title":"Bash parameter expansion"},{"location":"bash_parameter_expansion.html#bash-parameter-expansion","text":"","title":"Bash parameter expansion"},{"location":"bash_parameter_expansion.html#syntax","text":"Syntax Description ${parameter%suffix} Remove suffix ${parameter#prefix} Remove prefix ${parameter%%suffix} Remove long suffix ${parameter##prefix} Remove long prefix ${parameter/pattern/string} Replace first pattern match with string ${parameter//pattern/string} Replace all the pattern with string ${parameter/%pattern/string} Replace suffix pattern with string ${parameter/#pattern/string} Replace prefix patter with string","title":"Syntax"},{"location":"bash_parameter_expansion.html#substrings","text":"${FOO:0:3} Substring (position, length) ${FOO:(-3):3} Substring from the right","title":"Substrings"},{"location":"bash_parameter_expansion.html#length","text":"${#FOO} Length of $FOO","title":"Length"},{"location":"bash_parameter_expansion.html#default-values","text":"${FOO:-val} $FOO, or val if unset ${FOO:=val} Set $FOO to val if unset ${FOO:+val} val if $FOO is set ${FOO:?message} Show message and exit if $FOO is unset","title":"Default values"},{"location":"bash_parameter_expansion.html#substitution","text":"echo ${ food :- Cake } #=> $food or \"Cake\" STR = \"/path/to/foo.cpp\" echo ${ STR %.cpp } # /path/to/foo echo ${ STR %.cpp } .o # /path/to/foo.o echo ${ STR %/* } # /path/to echo ${ STR ##*. } # cpp (extension) echo ${ STR ##*/ } # foo.cpp (basepath) echo ${ STR #*/ } # path/to/foo.cpp echo ${ STR ##*/ } # foo.cpp echo ${ STR /foo/bar } # /path/to/bar.cpp","title":"Substitution"},{"location":"bash_parameter_expansion.html#basepath-dirpath","text":"SRC = \"/path/to/foo.cpp\" BASEPATH = ${ SRC ##*/ } echo $BASEPATH # => \"foo.cpp\" DIRPATH = ${ SRC % $BASEPATH } echo $DIRPATH # => \"/path/to/\"","title":"B**asepath &amp; Dirpath**"},{"location":"bash_parameter_expansion.html#slicing","text":"name = \"John\" echo ${ name } # => John echo ${ name : 0 : 2 } # => Jo echo ${ name :: 2 } # => Jo echo ${ name : :- 1 } # => Joh echo ${ name :(-1) } # => n echo ${ name :(-2) } # => hn echo ${ name :(-2): 2 } # => hn length = 2 echo ${ name : 0 : length } # => Jo","title":"Slicing"},{"location":"bash_parameter_expansion.html#transform","text":"STR = \"HELLO WORLD!\" echo ${ STR , } # => hELLO WORLD! echo ${ STR ,, } # => hello world! STR = \"hello world!\" echo ${ STR ^ } # => Hello world! echo ${ STR ^^ } # => HELLO WORLD! ARR =( hello World ) echo \" ${ ARR [@], } \" # => hello world echo \" ${ ARR [@]^ } \" # => Hello World \ud83d\udca1 Read more about bash parameter expansions here:","title":"Transform"}]}